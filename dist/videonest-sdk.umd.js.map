{"version":3,"file":"videonest-sdk.umd.js","sources":["../src/utils/debug.ts","../src/utils/helpers.ts","../src/utils/uploadOptimizationManager.ts","../src/core/client.ts","../src/components/VideonestEmbed.tsx","../src/index.ts"],"sourcesContent":["// src/utils/debug.ts\nimport debugModule from 'debug';\n\n// Debug mode configuration (disabled by default)\nlet isDebugEnabled: boolean = false;\n\n// Initialize debug module but don't enable by default\nconst debugInstance = debugModule('videonest-sdk');\n\n/**\n * Enable or disable debug mode for the SDK\n * @param enable Whether to enable debugging (true) or disable it (false)\n */\nexport function setDebugMode(enable: boolean): void {\n  isDebugEnabled = enable;\n  \n  if (enable) {\n    // Enable debug module\n    debugModule.enable('videonest-sdk');\n    \n    // Set localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem('debug', 'videonest-sdk');\n    }\n    \n    console.log('[videonest-sdk] Debug mode enabled');\n  } else {\n    // Disable debug module\n    debugModule.disable();\n    \n    // Clear localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.removeItem('debug');\n    }\n  }\n}\n\n/**\n * Get current debug mode status\n * @returns Boolean indicating if debug mode is enabled\n */\nexport function isDebugModeEnabled(): boolean {\n  return isDebugEnabled;\n}\n\n/**\n * Log messages only when debug mode is enabled\n */\nexport const log = function(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    debugInstance(message, ...args);\n  }\n};\n\n/**\n * Log messages that should always appear in console when debug mode is enabled,\n * or stay silent when debug mode is disabled\n */\nexport function forceLog(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    console.log(`[videonest-sdk] ${message}`, ...args);\n    debugInstance(message, ...args);\n  }\n}"," \nexport function generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }","// uploadOptimizationManager.ts - SDK v2 Upgrade\nimport { generateUUID } from './helpers'\nimport { VideonestConfig, VideoMetadata } from '../types'\n\nexport function calculateOptimalChunkSize(fileSize: number, connectionSpeed: number | null = null, totalConcurrentUploads: number = 1): number {\n  let baseChunkSize: number;\n  \n  // AGGRESSIVE base sizes for single SDK uploads (larger than frontend)\n  if (fileSize < 50 * 1024 * 1024) {        // < 50MB\n    baseChunkSize = 8 * 1024 * 1024;        // 8MB (vs 2MB frontend)\n  } else if (fileSize < 500 * 1024 * 1024) { // < 500MB  \n    baseChunkSize = 25 * 1024 * 1024;       // 25MB (vs 5MB frontend)\n  } else if (fileSize < 2 * 1024 * 1024 * 1024) { // < 2GB\n    baseChunkSize = 50 * 1024 * 1024;       // 50MB (vs 10MB frontend)\n  } else {\n    baseChunkSize = 100 * 1024 * 1024;      // 100MB (vs 20MB frontend)\n  }\n  \n  // SDK is always single video, so no reduction needed like frontend\n  // But still respect connection speed\n  if (connectionSpeed) {\n    if (connectionSpeed > 50) {             // > 50 Mbps - blazing fast\n      baseChunkSize = Math.min(baseChunkSize * 2, 200 * 1024 * 1024); // Up to 200MB!\n    } else if (connectionSpeed > 25) {      // > 25 Mbps - fast connection  \n      baseChunkSize = Math.min(baseChunkSize * 1.5, 100 * 1024 * 1024);\n    } else if (connectionSpeed > 10) {      // > 10 Mbps - decent connection\n      // Keep base size\n    } else if (connectionSpeed < 5) {       // < 5 Mbps - slow connection  \n      baseChunkSize = Math.max(baseChunkSize * 0.5, 1024 * 1024); // Min 1MB\n    }\n  }\n  \n  return Math.floor(baseChunkSize);\n}\n\n// Enhanced connection speed detector from frontend v2\nexport class ConnectionSpeedDetector {\n  private samples: number[] = [];\n  public avgSpeed: number | null = null;\n  private globalThroughput: number = 0;\n  \n  recordChunkUpload(chunkSize: number, uploadTime: number): number {\n    const speedMbps = (chunkSize * 8) / (uploadTime / 1000) / 1_000_000;\n    \n    this.samples.push(speedMbps);\n    if (this.samples.length > 5) { // Keep more samples for stability\n      this.samples.shift();\n    }\n    \n    // Calculate weighted average (more weight to recent samples)\n    this.avgSpeed = this.calculateWeightedAverage(this.samples);\n    this.globalThroughput = this.samples.reduce((a, b) => a + b, 0);\n    \n    return this.avgSpeed;\n  }\n  \n  private calculateWeightedAverage(samples: number[]): number {\n    if (samples.length === 0) return 0;\n    \n    let weightedSum = 0;\n    let totalWeight = 0;\n    \n    samples.forEach((speed, index) => {\n      const weight = index + 1; // More recent samples get higher weight\n      weightedSum += speed * weight;\n      totalWeight += weight;\n    });\n    \n    return weightedSum / totalWeight;\n  }\n  \n  shouldReduceConcurrency(): boolean {\n    return this.avgSpeed !== null && (this.avgSpeed < 5 || this.globalThroughput < 10);\n  }\n  \n  shouldIncreaseConcurrency(): boolean {\n    return this.avgSpeed !== null && this.avgSpeed > 20 && this.globalThroughput > 50 && this.samples.length >= 3;\n  }\n}\n\nexport class UploadOptimizationManager {\n  private file: File;\n  private metadata: VideoMetadata;\n  private config: VideonestConfig;\n  private currentConcurrency: number;\n  private maxConcurrency: number;\n  \n  private uploadQueue: Array<{\n    index: number;\n    uploadId: string;\n    retries: number;\n    maxRetries: number;\n    priority: number;\n  }> = [];\n  \n  private activeUploads = new Map();\n  private completedChunks = new Set<number>();\n  private failedChunks = new Set<number>();\n  private speedDetector = new ConnectionSpeedDetector();\n  \n  private chunkSize: number;\n  private totalChunks: number;\n  private uploadId: string = '';\n  \n  // Enhanced progress tracking\n  private chunkBytesUploaded = new Map<number, number>();\n  private totalBytesUploaded = 0;\n  private startTime: number = 0;\n  private lastProgressReport: number = 0;\n  private stalledChunks = new Set<number>();\n  private stallMonitor?: NodeJS.Timeout;\n  \n  constructor(file: File, metadata: VideoMetadata, config: VideonestConfig) {\n    this.file = file;\n    this.metadata = metadata;\n    this.config = config;\n    \n    // More aggressive for single SDK uploads\n    this.maxConcurrency = 10; // Higher than frontend's max of 6\n    this.currentConcurrency = 4; // Start higher than frontend's 2\n    \n    // Calculate chunk size with SDK-optimized settings\n    this.chunkSize = calculateOptimalChunkSize(file.size, null, 1);\n    this.totalChunks = Math.ceil(file.size / this.chunkSize);\n    \n    console.log(`🚀 SDK Upload manager initialized: ${this.totalChunks} chunks, ${this.maxConcurrency} max concurrency, ${(this.chunkSize / 1024 / 1024).toFixed(1)}MB chunk size`);\n  }\n  \n  async upload(onProgress: (progress: number) => void): Promise<{ uploadId: string; totalChunks: number }> {\n    const uploadId = generateUUID();\n    this.uploadId = uploadId;\n    this.startTime = Date.now();\n    \n    // Initialize bytes tracking for each chunk\n    for (let i = 0; i < this.totalChunks; i++) {\n      this.chunkBytesUploaded.set(i, 0);\n    }\n    \n    // Create upload queue with priority (first and last chunks prioritized)\n    for (let i = 0; i < this.totalChunks; i++) {\n      this.uploadQueue.push({\n        index: i,\n        uploadId,\n        retries: 0,\n        maxRetries: 3,\n        priority: this.calculateChunkPriority(i)\n      });\n    }\n    \n    // Sort queue by priority\n    this.uploadQueue.sort((a, b) => b.priority - a.priority);\n    \n    // Start workers\n    const workerPromises = [];\n    for (let i = 0; i < this.currentConcurrency; i++) {\n      workerPromises.push(this.uploadWorker(onProgress));\n    }\n    \n    // Monitor for stalled uploads\n    this.stallMonitor = setInterval(() => this.checkForStalledUploads(), 10000);\n    \n    await Promise.all(workerPromises);\n    \n    if (this.stallMonitor) {\n      clearInterval(this.stallMonitor);\n    }\n    \n    if (this.failedChunks.size > 0) {\n      throw new Error(`Failed to upload ${this.failedChunks.size} chunks after retries`);\n    }\n    \n    console.log(`✅ SDK Upload completed in ${((Date.now() - this.startTime) / 1000).toFixed(1)}s`);\n    return { uploadId, totalChunks: this.totalChunks };\n  }\n  \n  private calculateChunkPriority(index: number): number {\n    // First chunk gets highest priority (contains metadata)\n    if (index === 0) return 100;\n    // Last chunk gets high priority (allows early finalization check)\n    if (index === this.totalChunks - 1) return 90;\n    // Middle chunks get normal priority\n    return 50;\n  }\n  \n  private async uploadWorker(onProgress: (progress: number) => void): Promise<void> {\n    while (this.uploadQueue.length > 0 || this.activeUploads.size > 0) {\n      // Check if we should process more uploads\n      if (this.uploadQueue.length > 0 && this.activeUploads.size < this.currentConcurrency) {\n        const chunkInfo = this.uploadQueue.shift();\n        if (chunkInfo) {\n          try {\n            await this.uploadChunk(chunkInfo, onProgress);\n          } catch (error) {\n            this.handleChunkError(chunkInfo, error as Error);\n          }\n        }\n      } else {\n        // Wait for active uploads to complete\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    }\n  }\n  \n  private async uploadChunk(chunkInfo: any, onProgress: (progress: number) => void): Promise<any> {\n    const { index, uploadId } = chunkInfo;\n    \n    const start = index * this.chunkSize;\n    const end = Math.min(start + this.chunkSize, this.file.size);\n    const chunk = this.file.slice(start, end);\n    const chunkSize = chunk.size;\n    \n    if (chunkSize === 0) {\n      throw new Error(`Empty chunk detected for index ${index}`);\n    }\n    \n    this.activeUploads.set(index, { ...chunkInfo, startTime: Date.now() });\n    \n    const formData = new FormData();\n    formData.append('chunk', chunk);\n    formData.append('uploadId', uploadId);\n    formData.append('chunkIndex', index.toString());\n    formData.append('totalChunks', this.totalChunks.toString());\n    formData.append('fileName', this.file.name);\n    formData.append('fileSize', this.file.size.toString());\n    formData.append('totalConcurrentVideos', '1'); // Always 1 for SDK\n    \n    // Add metadata to first chunk\n    if (index === 0) {\n      formData.append('channelId', this.metadata.channelId.toString());\n      if (this.metadata.title) formData.append('title', this.metadata.title);\n      if (this.metadata.description) formData.append('description', this.metadata.description);\n      \n      if (this.metadata.tags) {\n        const tagsValue = Array.isArray(this.metadata.tags) \n          ? this.metadata.tags.join(',') \n          : this.metadata.tags;\n          \n        if (tagsValue && tagsValue.length > 0) {\n          formData.append('tags', tagsValue);\n        }\n      }\n    }\n    \n    const startTime = Date.now();\n    const baseUrl = this.config.baseUrl || 'https://api1.videonest.co';\n    \n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      \n      // Increased timeout for larger chunks\n      xhr.timeout = 120000; // 2 minutes\n      \n      xhr.upload.onprogress = (event) => {\n        if (event.lengthComputable) {\n          this.chunkBytesUploaded.set(index, event.loaded);\n          this.totalBytesUploaded = Array.from(this.chunkBytesUploaded.values())\n            .reduce((sum, bytes) => sum + bytes, 0);\n          \n          // Throttle progress updates\n          const now = Date.now();\n          if (now - this.lastProgressReport > 100) {\n            const progressPercentage = (this.totalBytesUploaded / this.file.size) * 100;\n            onProgress(progressPercentage);\n            this.lastProgressReport = now;\n          }\n        }\n      };\n      \n      // Use v2 route like frontend\n      xhr.open('POST', `${baseUrl}/upload/videos/upload-chunk-v2`);\n      xhr.setRequestHeader('Authorization', `Bearer ${this.config.apiKey}`);\n      \n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const result = JSON.parse(xhr.responseText);\n            if (!result.success) {\n              reject(new Error(result.message || 'Chunk upload failed'));\n            } else {\n              const uploadTime = Date.now() - startTime;\n              const currentSpeed = this.speedDetector.recordChunkUpload(chunkSize, uploadTime);\n              \n              this.activeUploads.delete(index);\n              this.completedChunks.add(index);\n              this.chunkBytesUploaded.set(index, chunkSize);\n              \n              // Dynamic concurrency adjustment\n              if (this.completedChunks.size % 3 === 0) {\n                this.adjustConcurrency(currentSpeed);\n              }\n              \n              resolve(result);\n            }\n          } catch (e) {\n            reject(new Error('Invalid response from server'));\n          }\n        } else {\n          reject(new Error(`HTTP error: ${xhr.status}`));\n        }\n      };\n      \n      xhr.onerror = () => reject(new Error('Network error during upload'));\n      xhr.ontimeout = () => reject(new Error('Upload timeout - chunk may be too large'));\n      \n      xhr.send(formData);\n    });\n  }\n  \n  private handleChunkError(chunkInfo: any, error: Error): void {\n    console.error(`Chunk ${chunkInfo.index} upload failed:`, error.message);\n    \n    if (chunkInfo.retries < chunkInfo.maxRetries) {\n      chunkInfo.retries++;\n      // Add delay before retry with exponential backoff\n      setTimeout(() => {\n        this.uploadQueue.unshift(chunkInfo); // Add to front for priority\n      }, Math.pow(2, chunkInfo.retries) * 1000);\n    } else {\n      this.failedChunks.add(chunkInfo.index);\n      this.activeUploads.delete(chunkInfo.index);\n    }\n  }\n  \n  private adjustConcurrency(currentSpeed: number): void {\n    const oldConcurrency = this.currentConcurrency;\n    \n    // More aggressive adjustments for single file SDK uploads\n    if (this.speedDetector.shouldReduceConcurrency()) {\n      this.currentConcurrency = Math.max(1, this.currentConcurrency - 1);\n      console.log(`🐌 SDK: Reducing concurrency to ${this.currentConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n    } else if (this.speedDetector.shouldIncreaseConcurrency() && this.currentConcurrency < this.maxConcurrency) {\n      // More aggressive increases for SDK\n      if (currentSpeed > 50) {\n        this.currentConcurrency = Math.min(this.currentConcurrency + 2, this.maxConcurrency);\n        console.log(`🚀 SDK: Boosting concurrency to ${this.currentConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n      } else if (currentSpeed > 25) {\n        this.currentConcurrency = Math.min(this.currentConcurrency + 1, this.maxConcurrency);\n        console.log(`⚡ SDK: Increasing concurrency to ${this.currentConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n      }\n    }\n    \n    // Start additional workers if concurrency increased\n    if (this.currentConcurrency > oldConcurrency && this.uploadQueue.length > 0) {\n      const additionalWorkers = this.currentConcurrency - oldConcurrency;\n      for (let i = 0; i < additionalWorkers; i++) {\n        this.uploadWorker(() => {}); // Start worker without progress callback\n      }\n    }\n  }\n  \n  private checkForStalledUploads(): void {\n    const now = Date.now();\n    const stallThreshold = 30000; // 30 seconds\n    \n    for (const [index, uploadInfo] of this.activeUploads.entries()) {\n      if (now - uploadInfo.startTime > stallThreshold) {\n        console.warn(`⚠️ SDK: Chunk ${index} appears stalled, will retry`);\n        this.stalledChunks.add(index);\n        \n        // Cancel and retry stalled upload\n        this.activeUploads.delete(index);\n        this.uploadQueue.unshift({\n          ...uploadInfo,\n          retries: uploadInfo.retries + 1\n        });\n      }\n    }\n  }\n  \n  getUploadStats() {\n    return {\n      totalChunks: this.totalChunks,\n      completedChunks: this.completedChunks.size,\n      failedChunks: this.failedChunks.size,\n      activeUploads: this.activeUploads.size,\n      currentConcurrency: this.currentConcurrency,\n      avgSpeed: this.speedDetector.avgSpeed,\n      progress: (this.totalBytesUploaded / this.file.size) * 100\n    };\n  }\n}","import { VideonestConfig, VideoMetadata, UploadOptions, UploadResult, VideoStatus } from '../types';\nimport { log, forceLog } from '../utils/debug';\nimport { generateUUID } from '../utils/helpers';\nimport { UploadOptimizationManager } from '../utils/uploadOptimizationManager';\n\nexport default class VideonestClient {\n  private config: VideonestConfig;\n\n  constructor(config: VideonestConfig) {\n    this.config = config;\n    log('VideonestClient initialized with channelId:', config.channelId);\n  }\n  \n  async uploadVideo(file: File, options: UploadOptions): Promise<UploadResult> {\n    const sessionId = generateUUID();\n    const startTime = Date.now();\n    \n    forceLog('Starting optimized video upload process');\n    forceLog(`File: ${file.name}, size: ${file.size} bytes`);\n    \n    try {\n      const { \n        metadata, \n        onProgress = () => {}, \n        thumbnail\n      } = options;\n      \n      // Check if thumbnail is provided\n      if (!thumbnail) {\n        forceLog('Error: Thumbnail is required');\n        throw new Error('Thumbnail is required for video upload');\n      }\n      \n      forceLog('Upload options:', { \n        metadata, \n        hasThumbnail: !!thumbnail\n      });\n      \n      // Make sure channelId is included in metadata\n      const uploadMetadata = {\n        ...metadata,\n        channelId: this.config.channelId,\n      };\n      forceLog('Upload metadata:', uploadMetadata);\n      \n      // Get estimated chunk count before starting\n      const uploadManager = new UploadOptimizationManager(\n        file, \n        uploadMetadata, \n        this.config\n      );\n      const estimatedChunks = uploadManager.getTotalChunks();\n      \n      // Track upload start with estimated chunk count\n      await this.trackVideoUpload('start', {\n        sessionId,\n        userId: 'SDK',\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: estimatedChunks,\n        startTime,\n        status: 'in_progress'\n      });\n      \n      // Upload chunks with optimization\n      const { uploadId, totalChunks } = await uploadManager.upload(onProgress);\n      \n      forceLog(`All chunks uploaded. Finalizing upload... (uploadId: ${uploadId}, totalChunks: ${totalChunks})`);\n      \n      // Update session with actual chunk count if different\n      if (totalChunks !== estimatedChunks) {\n        await this.trackVideoUpload('chunks_complete', {\n          sessionId,\n          userId: 'SDK',\n          chunksCount: totalChunks,\n          status: 'chunks_completed'\n        });\n      }\n      \n      // Finalize using v2 route with metadata in request body\n      const finalData = { \n        fileName: file.name, \n        uploadId: uploadId,\n        totalChunks: totalChunks.toString(),\n        // Include metadata in finalization request (like frontend v2)\n        title: uploadMetadata.title || 'Untitled Video',\n        description: uploadMetadata.description || '',\n        tags: uploadMetadata.tags ? (Array.isArray(uploadMetadata.tags) ? uploadMetadata.tags.join(',') : uploadMetadata.tags) : ''\n      };\n      forceLog('Finalize request data:', finalData);\n      \n      // Use new SDK v2 finalize route\n      const finalizeResponse = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/finalize-v2`, {\n        method: 'POST',\n        body: JSON.stringify(finalData),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      forceLog(`Finalize response status: ${finalizeResponse.status}`);\n      const finalizeResult = await finalizeResponse.json();\n      forceLog('Finalize response data:', finalizeResult);\n      \n      if (!finalizeResult.success) {\n        forceLog(`Finalization failed: ${finalizeResult.message}`);\n        throw new Error(finalizeResult.message || 'Upload finalization failed');\n      }\n      \n      forceLog('Upload successfully finalized');\n      \n      // Upload the provided thumbnail\n      forceLog('Uploading user-provided thumbnail');\n      await this.uploadThumbnail(thumbnail, finalizeResult.video.id);\n      forceLog('Upload process completed successfully');\n      \n      // Track successful completion\n      await this.trackVideoUpload('complete', {\n        sessionId,\n        userId: 'SDK',\n        videoId: finalizeResult.video?.id || 0,\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: totalChunks,\n        startTime,\n        status: 'completed',\n        uploadId: uploadId\n      });\n      \n      return finalizeResult;\n    } catch (error) {\n      forceLog(`Upload error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      \n      // Track failed upload\n      await this.trackVideoUpload('failed', {\n        sessionId,\n        userId: 'SDK',\n        videoId: 0,\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: 0,\n        startTime,\n        status: 'failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'An unexpected error occurred during upload' \n      };\n    }\n  }\n\n  private async trackVideoUpload(action: string, sessionData: any) {\n    log(\"Tracking video upload:\", action, sessionData);\n    \n    try {\n      let endpoint = '';\n      let method = 'POST';\n      let requestBody: any;\n      const baseUrl = 'https://api1.videonest.co';\n  \n      if (action === 'start') {\n        // CREATE new session\n        endpoint = '/video-stats/upload-sessions';\n        method = 'POST';\n        requestBody = {\n          session_id: sessionData.sessionId,\n          user_id: sessionData.userId,\n          video_id: sessionData.videoId || 0, // Will be updated later\n          filename: sessionData.filename,\n          file_size: sessionData.fileSize,\n          chunks_count: sessionData.chunksCount || 0,\n          status: 'in_progress'\n          // start_time will default to NOW() in the API\n        };\n      } else if (action === 'complete' || action === 'failed') {\n        // UPDATE existing session\n        endpoint = `/video-stats/upload-sessions/${sessionData.sessionId}`;\n        method = 'POST'; // API uses POST for updates\n        requestBody = {\n          video_id: sessionData.videoId,\n          end_time: new Date().toISOString(),\n          status: sessionData.status\n        };\n        \n        if (sessionData.startTime) {\n          const duration = Date.now() - sessionData.startTime;\n          requestBody.total_duration = `${Math.floor(duration / 1000)} seconds`;\n          \n          // Calculate average speed in Mbps\n          if (sessionData.fileSize && duration > 0) {\n            const speedBps = (sessionData.fileSize * 8) / (duration / 1000); // bits per second\n            requestBody.avg_speed_mbps = parseFloat((speedBps / 1_000_000).toFixed(2)); // Convert to Mbps\n          }\n        }\n      }\n  \n      const url = `${baseUrl}${endpoint}`;\n      log(\"Upload session request:\", { action, url, method, body: requestBody });\n  \n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n      };\n\n      // Add authentication headers\n      if (this.config.apiKey) {\n        headers['X-API-Key'] = this.config.apiKey;\n      }\n\n      if (this.config.channelId) {\n        headers['X-Channel-ID'] = this.config.channelId.toString();\n      }\n  \n      const response = await fetch(url, {\n        method,\n        headers,\n        body: JSON.stringify(requestBody),\n      });\n  \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        log('Failed to track upload session:', errorData);\n        return { success: false, error: 'Failed to track upload session' };\n      }\n  \n      const data = await response.json();\n      return { success: true, ...data };\n    } catch (error) {\n      log('Error tracking upload session:', error instanceof Error ? error.message : String(error));\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to track upload session' };\n    }\n  }\n\n\n  private async uploadThumbnail(thumbnailFile: File, videoId: string): Promise<any> {\n    \n    const formData = new FormData();\n    formData.append('thumbnail', thumbnailFile);\n\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/send-thumbnail`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Thumbnail upload failed');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to upload thumbnail');\n    }\n  }\n  \n\n\n async getVideoStatus(videoId: number): Promise<VideoStatus> {\n    \n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/status`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to get video status');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to get video status');\n    }\n  }\n\n\n\n\n\n\n  async listVideos(): Promise<{ success: boolean, videos?: any[], message?: string }> {\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      log(`Videos list response status: ${response.status}`);\n      const result = await response.json();\n      log('Videos list response data:', result);\n      \n      if (!result.success) {\n        log(`Videos list fetch failed: ${result.message || 'Unknown error'}`);\n        return {\n          success: false,\n          message: result.message || 'Failed to retrieve videos'\n        };\n      }\n      \n      log(`Successfully retrieved ${result.videos ? result.videos.length : 0} videos`);\n      return result;\n    } catch (error) {\n      log(`Videos list error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Failed to retrieve videos'\n      };\n    }\n  }\n\n\n\n\n}","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestEmbedProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestEmbed: React.FC<VideonestEmbedProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/single/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestEmbed;","import { log, forceLog, setDebugMode, isDebugModeEnabled } from './utils/debug';\nimport VideonestClient from './core/client';\nimport { VideonestConfig } from './types';\nimport VideonestEmbed from './components/VideonestEmbed';\n\nexport * from './types';\nexport { setDebugMode, isDebugModeEnabled } from './utils/debug';\n\nexport { VideonestEmbed }; // Export the component\n\n/**\n * Upload a video to VideoNest\n * @param file The video file to upload\n * @param options Upload options including metadata\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function uploadVideo(file: File, options: any, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.uploadVideo(file, options);\n}\n\n/**\n * Get the status of a video\n * @param videoId The ID of the video to check status\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function getVideoStatus(videoId: number, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.getVideoStatus(videoId);\n}\n\n/**\n * List all videos for the channel\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function listVideos(config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.listVideos();\n}\n\n"],"names":["isDebugEnabled","debugInstance","debugModule","log","message","args","forceLog","console","generateUUID","replace","c","r","Math","random","toString","ConnectionSpeedDetector","constructor","this","samples","avgSpeed","globalThroughput","recordChunkUpload","chunkSize","uploadTime","speedMbps","push","length","shift","calculateWeightedAverage","reduce","a","b","weightedSum","totalWeight","forEach","speed","index","weight","shouldReduceConcurrency","shouldIncreaseConcurrency","UploadOptimizationManager","file","metadata","config","uploadQueue","activeUploads","Map","completedChunks","Set","failedChunks","speedDetector","uploadId","chunkBytesUploaded","totalBytesUploaded","startTime","lastProgressReport","stalledChunks","maxConcurrency","currentConcurrency","fileSize","connectionSpeed","baseChunkSize","min","max","floor","calculateOptimalChunkSize","size","totalChunks","ceil","toFixed","upload","onProgress","Date","now","i","set","retries","maxRetries","priority","calculateChunkPriority","sort","workerPromises","uploadWorker","stallMonitor","setInterval","checkForStalledUploads","Promise","all","clearInterval","Error","chunkInfo","uploadChunk","error","handleChunkError","resolve","setTimeout","start","end","chunk","slice","formData","FormData","append","name","channelId","title","description","tags","tagsValue","Array","isArray","join","baseUrl","reject","xhr","XMLHttpRequest","timeout","onprogress","event","lengthComputable","loaded","from","values","sum","bytes","progressPercentage","open","setRequestHeader","apiKey","onload","status","result","JSON","parse","responseText","success","currentSpeed","delete","add","adjustConcurrency","e","onerror","ontimeout","send","unshift","pow","oldConcurrency","additionalWorkers","uploadInfo","entries","warn","getUploadStats","progress","VideonestClient","uploadVideo","options","sessionId","thumbnail","hasThumbnail","uploadMetadata","uploadManager","estimatedChunks","getTotalChunks","trackVideoUpload","userId","filename","chunksCount","finalData","fileName","finalizeResponse","fetch","method","body","stringify","headers","Authorization","finalizeResult","json","uploadThumbnail","video","id","videoId","_a","action","sessionData","requestBody","endpoint","session_id","user_id","video_id","file_size","chunks_count","end_time","toISOString","duration","total_duration","speedBps","avg_speed_mbps","parseFloat","url","response","ok","errorData","catch","String","thumbnailFile","getVideoStatus","listVideos","videos","style","primaryColor","secondaryColor","darkMode","width","height","showTitle","showDescription","embedUrl","params","React","createElement","src","frameBorder","allow","allowFullScreen","async","enable","window","localStorage","setItem","disable","removeItem"],"mappings":"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"}