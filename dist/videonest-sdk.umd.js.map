{"version":3,"file":"videonest-sdk.umd.js","sources":["../src/utils/debug.ts","../src/utils/helpers.ts","../src/utils/uploadOptimizationManager.ts","../src/core/client.ts","../src/components/VideonestEmbed.tsx","../src/index.ts"],"sourcesContent":["// src/utils/debug.ts\nimport debugModule from 'debug';\n\n// Debug mode configuration (disabled by default)\nlet isDebugEnabled: boolean = false;\n\n// Initialize debug module but don't enable by default\nconst debugInstance = debugModule('videonest-sdk');\n\n/**\n * Enable or disable debug mode for the SDK\n * @param enable Whether to enable debugging (true) or disable it (false)\n */\nexport function setDebugMode(enable: boolean): void {\n  isDebugEnabled = enable;\n  \n  if (enable) {\n    // Enable debug module\n    debugModule.enable('videonest-sdk');\n    \n    // Set localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem('debug', 'videonest-sdk');\n    }\n    \n    console.log('[videonest-sdk] Debug mode enabled');\n  } else {\n    // Disable debug module\n    debugModule.disable();\n    \n    // Clear localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.removeItem('debug');\n    }\n  }\n}\n\n/**\n * Get current debug mode status\n * @returns Boolean indicating if debug mode is enabled\n */\nexport function isDebugModeEnabled(): boolean {\n  return isDebugEnabled;\n}\n\n/**\n * Log messages only when debug mode is enabled\n */\nexport const log = function(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    debugInstance(message, ...args);\n  }\n};\n\n/**\n * Log messages that should always appear in console when debug mode is enabled,\n * or stay silent when debug mode is disabled\n */\nexport function forceLog(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    console.log(`[videonest-sdk] ${message}`, ...args);\n    debugInstance(message, ...args);\n  }\n}"," \nexport function generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }","// uploadOptimizationManager.ts\nimport { generateUUID } from './helpers'\nimport { VideonestConfig, VideoMetadata } from '../types'\n\n\nexport function calculateOptimalChunkSize(fileSize: number, connectionSpeed: number | null = null): number {\n  let baseChunkSize: number;\n  \n  // MUCH LARGER base sizes for single file uploads\n  if (fileSize < 50 * 1024 * 1024) {        // < 50MB\n    baseChunkSize = 5 * 1024 * 1024;        // 5MB\n  } else if (fileSize < 500 * 1024 * 1024) { // < 500MB  \n    baseChunkSize = 15 * 1024 * 1024;       // 15MB\n  } else if (fileSize < 2 * 1024 * 1024 * 1024) { // < 2GB\n    baseChunkSize = 35 * 1024 * 1024;       // 35MB\n  } else {\n    baseChunkSize = 75 * 1024 * 1024;       // 75MB\n  }\n  \n  // AGGRESSIVE speed-based adjustments for single file\n  if (connectionSpeed) {\n    if (connectionSpeed > 50) {             // > 50 Mbps - blazing fast\n      baseChunkSize = Math.min(baseChunkSize * 3, 150 * 1024 * 1024); // Up to 150MB chunks!\n    } else if (connectionSpeed > 15) {      // > 15 Mbps - fast connection  \n      baseChunkSize = Math.min(baseChunkSize * 2, 100 * 1024 * 1024); // Up to 100MB chunks\n    } else if (connectionSpeed > 8) {       // > 8 Mbps - decent connection\n      baseChunkSize = Math.min(baseChunkSize * 1.5, 50 * 1024 * 1024);\n    } else if (connectionSpeed < 3) {       // < 3 Mbps - slow connection  \n      baseChunkSize = Math.max(baseChunkSize * 0.3, 1024 * 1024); // Min 1MB\n    }\n  }\n  \n  return Math.floor(baseChunkSize);\n}\n\nexport class ConnectionSpeedDetector {\n  private samples: number[] = [];\n  public avgSpeed: number | null = null;\n  \n  recordChunkUpload(chunkSize: number, uploadTime: number): number {\n    const speedMbps = (chunkSize * 8) / (uploadTime / 1000) / 1_000_000;\n    this.samples.push(speedMbps);\n    \n    // Keep only last 3 samples for FASTER reaction\n    if (this.samples.length > 3) {\n      this.samples.shift();\n    }\n    \n    this.avgSpeed = this.samples.reduce((a, b) => a + b) / this.samples.length;\n    return this.avgSpeed;\n  }\n  \n  shouldAdjustConcurrency(): boolean {\n    return this.samples.length >= 2; // Adjust after just 2 samples\n  }\n}\n\nexport class UploadOptimizationManager {\n  private file: File;\n  private metadata: VideoMetadata;\n  private config: VideonestConfig;\n  private maxConcurrency: number;\n  private maxPossibleConcurrency: number = 12; // Aggressive for single file\n  \n  private uploadQueue: Array<{\n    index: number;\n    uploadId: string;\n    retries: number;\n    maxRetries: number;\n  }> = [];\n  \n  private activeUploads = new Map();\n  private completedChunks = new Set<number>();\n  private failedChunks = new Set<number>();\n  private speedDetector = new ConnectionSpeedDetector();\n  \n  private chunkSize: number;\n  private totalChunks: number;\n  private uploadId: string = '';\n  \n  // Track bytes uploaded per chunk\n  private chunkBytesUploaded = new Map<number, number>();\n  private totalBytesUploaded = 0;\n  \n  // Track worker promises for dynamic scaling\n  private workerPromises: Promise<void>[] = [];\n  \n  constructor(file: File, metadata: VideoMetadata, config: VideonestConfig) {\n    this.file = file;\n    this.metadata = metadata;\n    this.config = config;\n    \n    // Start aggressive for single file uploads\n    this.maxConcurrency = 6;\n    \n    // Calculate chunk size ONCE and stick with it\n    this.chunkSize = calculateOptimalChunkSize(file.size);\n    this.totalChunks = Math.ceil(file.size / this.chunkSize);\n  }\n  \n  async upload(onProgress: (progress: number) => void): Promise<{ uploadId: string; totalChunks: number }> {\n    const uploadId = generateUUID();\n    this.uploadId = uploadId;\n    \n    // Initialize bytes tracking for each chunk\n    for (let i = 0; i < this.totalChunks; i++) {\n      this.chunkBytesUploaded.set(i, 0);\n    }\n    \n    // Create upload queue with FIXED chunk calculations\n    for (let i = 0; i < this.totalChunks; i++) {\n      this.uploadQueue.push({\n        index: i,\n        uploadId,\n        retries: 0,\n        maxRetries: 2\n      });\n    }\n    \n    // Start initial concurrent uploads\n    for (let i = 0; i < this.maxConcurrency; i++) {\n      const workerPromise = this.uploadWorker(onProgress);\n      this.workerPromises.push(workerPromise);\n    }\n    \n    // Wait for all uploads to complete\n    await Promise.all(this.workerPromises);\n    \n    if (this.failedChunks.size > 0) {\n      throw new Error(`Failed to upload ${this.failedChunks.size} chunks`);\n    }\n    \n    return { uploadId, totalChunks: this.totalChunks };\n  }\n  \n  private async uploadWorker(onProgress: (progress: number) => void): Promise<void> {\n    while (this.uploadQueue.length > 0 || this.activeUploads.size > 0) {\n      // Get next chunk to upload\n      const chunkInfo = this.uploadQueue.shift();\n      if (!chunkInfo) {\n        // Wait for active uploads to finish\n        await new Promise(resolve => setTimeout(resolve, 100));\n        continue;\n      }\n      \n      try {\n        await this.uploadChunk(chunkInfo, onProgress);\n      } catch (error) {\n        console.error(`Chunk ${chunkInfo.index} upload failed:`, error);\n        \n        if (chunkInfo.retries < chunkInfo.maxRetries) {\n          chunkInfo.retries++;\n          this.uploadQueue.push(chunkInfo); // Retry\n        } else {\n          this.failedChunks.add(chunkInfo.index);\n        }\n      }\n    }\n  }\n  \n  private async uploadChunk(chunkInfo: { index: number; uploadId: string; retries: number; maxRetries: number }, onProgress: (progress: number) => void): Promise<any> {\n    const { index, uploadId } = chunkInfo;\n    \n    // Use FIXED chunk size calculations - no dynamic changes\n    const start = index * this.chunkSize;\n    const end = Math.min(start + this.chunkSize, this.file.size);\n    const chunk = this.file.slice(start, end);\n    const chunkSize = chunk.size; // Actual chunk size\n    \n    if (chunkSize === 0) {\n      throw new Error(`Empty chunk detected for index ${index}`);\n    }\n    \n    this.activeUploads.set(index, chunkInfo);\n    \n    const formData = new FormData();\n    formData.append('chunk', chunk);\n    formData.append('uploadId', uploadId);\n    formData.append('chunkIndex', index.toString());\n    formData.append('totalChunks', this.totalChunks.toString());\n    formData.append('fileName', this.file.name);\n    formData.append('fileSize', this.file.size.toString());\n    \n    // Add metadata to first chunk\n    if (index === 0) {\n      formData.append('channelId', this.metadata.channelId.toString());\n      if (this.metadata.title) formData.append('title', this.metadata.title);\n      if (this.metadata.description) formData.append('description', this.metadata.description);\n      \n      if (this.metadata.tags) {\n        // Handle tags that could be either string or array\n        const tagsValue = Array.isArray(this.metadata.tags) \n          ? this.metadata.tags.join(',') \n          : this.metadata.tags;\n          \n        if (tagsValue && tagsValue.length > 0) {\n          formData.append('tags', tagsValue);\n        }\n      }\n    }\n    \n    const startTime = Date.now();\n    const baseUrl = this.config.baseUrl || 'https://api1.videonest.co';\n    \n    // Use XMLHttpRequest instead of fetch to track progress during upload\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      \n      // Track progress during upload\n      xhr.upload.onprogress = (event) => {\n        if (event.lengthComputable) {\n          // Update progress for this specific chunk\n          const chunkProgress = event.loaded;\n          this.chunkBytesUploaded.set(index, chunkProgress);\n          \n          // Calculate total bytes across all chunks\n          this.totalBytesUploaded = Array.from(this.chunkBytesUploaded.values())\n            .reduce((sum, bytes) => sum + bytes, 0);\n          \n          // Report progress as percentage\n          const progressPercentage = (this.totalBytesUploaded / this.file.size) * 100;\n          onProgress(progressPercentage);\n        }\n      };\n      \n      xhr.open('POST', `${baseUrl}/sdk/${this.config.channelId}/upload-chunk`);\n      xhr.setRequestHeader('Authorization', `Bearer ${this.config.apiKey}`);\n      \n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const result = JSON.parse(xhr.responseText);\n            if (!result.success) {\n              reject(new Error(result.message || 'Chunk upload failed'));\n            } else {\n              const uploadTime = Date.now() - startTime;\n              // Record upload time for speed calculation\n              const currentSpeed = this.speedDetector.recordChunkUpload(chunkSize, uploadTime);\n              \n              // Mark this chunk as completed\n              this.activeUploads.delete(index);\n              this.completedChunks.add(index);\n              \n              // Set final chunk size when completed\n              this.chunkBytesUploaded.set(index, chunkSize);\n              \n              // ONLY adjust concurrency, NOT chunk size\n              if (this.speedDetector.shouldAdjustConcurrency() && index < this.totalChunks * 0.7) {\n                this.adjustConcurrency(currentSpeed);\n              }\n              \n              resolve(result);\n            }\n          } catch (e) {\n            reject(new Error('Invalid response from server'));\n          }\n        } else {\n          reject(new Error('HTTP error: ' + xhr.status));\n        }\n      };\n      \n      xhr.onerror = () => reject(new Error('Network error during upload'));\n      xhr.send(formData);\n    });\n  }\n  \n  private adjustConcurrency(currentSpeed: number): void {\n    const oldConcurrency = this.maxConcurrency;\n    \n    // AGGRESSIVE scaling for single-file uploads\n    if (currentSpeed > 50 && this.maxConcurrency < this.maxPossibleConcurrency) {\n      this.maxConcurrency = Math.min(this.maxConcurrency + 2, this.maxPossibleConcurrency);\n      console.log(`🚀 SDK: Boosting concurrency to ${this.maxConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n    } else if (currentSpeed > 25 && this.maxConcurrency < 10) {\n      this.maxConcurrency = Math.min(this.maxConcurrency + 1, 10);\n      console.log(`⚡ SDK: Increasing concurrency to ${this.maxConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n    } else if (currentSpeed > 15 && this.maxConcurrency < 8) {\n      this.maxConcurrency = Math.min(this.maxConcurrency + 1, 8);\n      console.log(`⚡ SDK: Moderate increase to ${this.maxConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n    } else if (currentSpeed < 5 && this.maxConcurrency > 2) {\n      this.maxConcurrency = Math.max(this.maxConcurrency - 1, 2);\n      console.log(`🐌 SDK: Reducing concurrency to ${this.maxConcurrency} (${currentSpeed.toFixed(1)} Mbps)`);\n    } else if (currentSpeed < 1 && this.maxConcurrency > 1) {\n      this.maxConcurrency = 1;\n      console.log(`🚨 SDK: Emergency single thread (${currentSpeed.toFixed(1)} Mbps)`);\n    }\n    \n    // Start additional workers if concurrency increased\n    if (this.maxConcurrency > oldConcurrency) {\n      const additionalWorkers = this.maxConcurrency - oldConcurrency;\n      for (let i = 0; i < additionalWorkers; i++) {\n        const workerPromise = this.uploadWorker(() => {}); // Empty progress callback for additional workers\n        this.workerPromises.push(workerPromise);\n      }\n    }\n  }\n}","import { VideonestConfig, VideoMetadata, UploadOptions, UploadResult, VideoStatus } from '../types';\nimport { log, forceLog } from '../utils/debug';\nimport { generateUUID } from '../utils/helpers';\nimport { UploadOptimizationManager } from '../utils/uploadOptimizationManager';\n\nexport default class VideonestClient {\n  private config: VideonestConfig;\n\n  constructor(config: VideonestConfig) {\n    this.config = config;\n    log('VideonestClient initialized with channelId:', config.channelId);\n  }\n  \n  async uploadVideo(file: File, options: UploadOptions): Promise<UploadResult> {\n    const sessionId = generateUUID();\n    const startTime = Date.now();\n    \n    forceLog('Starting optimized video upload process');\n    forceLog(`File: ${file.name}, size: ${file.size} bytes`);\n    \n    // Track upload start\n    await this.trackVideoUpload('start', {\n      sessionId,\n      userId: 'SDK',\n      filename: file.name,\n      fileSize: file.size,\n      chunksCount: 0, // Will be calculated\n      startTime,\n      status: 'in_progress'\n    });\n    \n    try {\n      const { \n        metadata, \n        onProgress = () => {}, \n        thumbnail\n      } = options;\n      \n      // Check if thumbnail is provided\n      if (!thumbnail) {\n        forceLog('Error: Thumbnail is required');\n        throw new Error('Thumbnail is required for video upload');\n      }\n      \n      forceLog('Upload options:', { \n        metadata, \n        hasThumbnail: !!thumbnail\n      });\n      \n      // Make sure channelId is included in metadata\n      const uploadMetadata = {\n        ...metadata,\n        channelId: this.config.channelId,\n      };\n      forceLog('Upload metadata:', uploadMetadata);\n      \n      // Create upload optimization manager\n      const uploadManager = new UploadOptimizationManager(\n        file, \n        uploadMetadata, \n        this.config\n      );\n      \n      // Upload with optimization\n      const { uploadId, totalChunks } = await uploadManager.upload(onProgress);\n      \n      forceLog(`All chunks uploaded. Finalizing upload... (uploadId: ${uploadId}, totalChunks: ${totalChunks})`);\n      \n      // Finalize the upload\n      const finalData = { \n        fileName: file.name, \n        uploadId: uploadId,\n        totalChunks: totalChunks.toString() \n      };\n      forceLog('Finalize request data:', finalData);\n      \n      const finalizeResponse = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/finalize`, {\n        method: 'POST',\n        body: JSON.stringify(finalData),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      forceLog(`Finalize response status: ${finalizeResponse.status}`);\n      const finalizeResult = await finalizeResponse.json();\n      forceLog('Finalize response data:', finalizeResult);\n      \n      if (!finalizeResult.success) {\n        forceLog(`Finalization failed: ${finalizeResult.message}`);\n        throw new Error(finalizeResult.message || 'Upload finalization failed');\n      }\n      \n      forceLog('Upload successfully finalized');\n      \n      // Upload the provided thumbnail\n      forceLog('Uploading user-provided thumbnail');\n      await this.uploadThumbnail(thumbnail, finalizeResult.video.id);\n      forceLog('Upload process completed successfully');\n      \n      // Track successful completion\n      await this.trackVideoUpload('complete', {\n        sessionId,\n        userId: 'SDK',\n        videoId: finalizeResult.video?.id || 0,\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: totalChunks,\n        startTime,\n        status: 'completed'\n      });\n      \n      return finalizeResult;\n    } catch (error) {\n      forceLog(`Upload error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      \n      // Track failed upload\n      await this.trackVideoUpload('failed', {\n        sessionId,\n        userId: 'SDK',\n        videoId: 0,\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: 0,\n        startTime,\n        status: 'failed'\n      });\n      \n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'An unexpected error occurred during upload' \n      };\n    }\n  }\n\n\n  private async trackVideoUpload(action: string, sessionData: any) {\n    log(\"Tracking video upload:\", action, sessionData);\n    \n    try {\n      let endpoint = '';\n      let method = 'POST';\n      let requestBody: any;\n      const baseUrl = 'https://api1.videonest.co';\n  \n      if (action === 'start') {\n        // CREATE new session\n        endpoint = '/video-stats/upload-sessions';\n        method = 'POST';\n        requestBody = {\n          session_id: sessionData.sessionId,\n          user_id: sessionData.userId,\n          video_id: sessionData.videoId || 0, // Will be updated later\n          filename: sessionData.filename,\n          file_size: sessionData.fileSize,\n          chunks_count: sessionData.chunksCount || 0,\n          status: 'in_progress'\n          // start_time will default to NOW() in the API\n        };\n      } else if (action === 'complete' || action === 'failed') {\n        // UPDATE existing session\n        endpoint = `/video-stats/upload-sessions/${sessionData.sessionId}`;\n        method = 'POST'; // API uses POST for updates\n        requestBody = {\n          video_id: sessionData.videoId,\n          end_time: new Date().toISOString(),\n          status: sessionData.status\n        };\n        \n        if (sessionData.startTime) {\n          const duration = Date.now() - sessionData.startTime;\n          requestBody.total_duration = `${Math.floor(duration / 1000)} seconds`;\n          \n          // Calculate average speed in Mbps\n          if (sessionData.fileSize && duration > 0) {\n            const speedBps = (sessionData.fileSize * 8) / (duration / 1000); // bits per second\n            requestBody.avg_speed_mbps = parseFloat((speedBps / 1_000_000).toFixed(2)); // Convert to Mbps\n          }\n        }\n      }\n  \n      const url = `${baseUrl}${endpoint}`;\n      log(\"Upload session request:\", { action, url, method, body: requestBody });\n  \n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n      };\n\n      // Add authentication headers\n      if (this.config.apiKey) {\n        headers['X-API-Key'] = this.config.apiKey;\n      }\n\n      if (this.config.channelId) {\n        headers['X-Channel-ID'] = this.config.channelId.toString();\n      }\n  \n      const response = await fetch(url, {\n        method,\n        headers,\n        body: JSON.stringify(requestBody),\n      });\n  \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        log('Failed to track upload session:', errorData);\n        return { success: false, error: 'Failed to track upload session' };\n      }\n  \n      const data = await response.json();\n      return { success: true, ...data };\n    } catch (error) {\n      log('Error tracking upload session:', error instanceof Error ? error.message : String(error));\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to track upload session' };\n    }\n  }\n\n\n  private async uploadThumbnail(thumbnailFile: File, videoId: string): Promise<any> {\n    \n    const formData = new FormData();\n    formData.append('thumbnail', thumbnailFile);\n\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/send-thumbnail`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Thumbnail upload failed');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to upload thumbnail');\n    }\n  }\n  \n\n\n async getVideoStatus(videoId: number): Promise<VideoStatus> {\n    \n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/status`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to get video status');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to get video status');\n    }\n  }\n\n\n\n\n\n\n  async listVideos(): Promise<{ success: boolean, videos?: any[], message?: string }> {\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      log(`Videos list response status: ${response.status}`);\n      const result = await response.json();\n      log('Videos list response data:', result);\n      \n      if (!result.success) {\n        log(`Videos list fetch failed: ${result.message || 'Unknown error'}`);\n        return {\n          success: false,\n          message: result.message || 'Failed to retrieve videos'\n        };\n      }\n      \n      log(`Successfully retrieved ${result.videos ? result.videos.length : 0} videos`);\n      return result;\n    } catch (error) {\n      log(`Videos list error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Failed to retrieve videos'\n      };\n    }\n  }\n\n\n\n\n}","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestEmbedProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestEmbed: React.FC<VideonestEmbedProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/single/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestEmbed;","import { log, forceLog, setDebugMode, isDebugModeEnabled } from './utils/debug';\nimport VideonestClient from './core/client';\nimport { VideonestConfig } from './types';\nimport VideonestEmbed from './components/VideonestEmbed';\n\nexport * from './types';\nexport { setDebugMode, isDebugModeEnabled } from './utils/debug';\n\nexport { VideonestEmbed }; // Export the component\n\n/**\n * Upload a video to VideoNest\n * @param file The video file to upload\n * @param options Upload options including metadata\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function uploadVideo(file: File, options: any, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.uploadVideo(file, options);\n}\n\n/**\n * Get the status of a video\n * @param videoId The ID of the video to check status\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function getVideoStatus(videoId: number, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.getVideoStatus(videoId);\n}\n\n/**\n * List all videos for the channel\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function listVideos(config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.listVideos();\n}\n\n"],"names":["isDebugEnabled","debugInstance","debugModule","log","message","args","forceLog","console","generateUUID","replace","c","r","Math","random","toString","ConnectionSpeedDetector","constructor","this","samples","avgSpeed","recordChunkUpload","chunkSize","uploadTime","speedMbps","push","length","shift","reduce","a","b","shouldAdjustConcurrency","UploadOptimizationManager","file","metadata","config","maxPossibleConcurrency","uploadQueue","activeUploads","Map","completedChunks","Set","failedChunks","speedDetector","uploadId","chunkBytesUploaded","totalBytesUploaded","workerPromises","maxConcurrency","fileSize","connectionSpeed","baseChunkSize","min","max","floor","calculateOptimalChunkSize","size","totalChunks","ceil","upload","onProgress","i","set","index","retries","maxRetries","workerPromise","uploadWorker","Promise","all","Error","chunkInfo","uploadChunk","error","add","resolve","setTimeout","start","end","chunk","slice","formData","FormData","append","name","channelId","title","description","tags","tagsValue","Array","isArray","join","startTime","Date","now","baseUrl","reject","xhr","XMLHttpRequest","onprogress","event","lengthComputable","chunkProgress","loaded","from","values","sum","bytes","progressPercentage","open","setRequestHeader","apiKey","onload","status","result","JSON","parse","responseText","success","currentSpeed","delete","adjustConcurrency","e","onerror","send","oldConcurrency","toFixed","additionalWorkers","VideonestClient","uploadVideo","options","sessionId","trackVideoUpload","userId","filename","chunksCount","thumbnail","hasThumbnail","uploadMetadata","uploadManager","finalData","fileName","finalizeResponse","fetch","method","body","stringify","headers","Authorization","finalizeResult","json","uploadThumbnail","video","id","videoId","_a","action","sessionData","requestBody","endpoint","session_id","user_id","video_id","file_size","chunks_count","end_time","toISOString","duration","total_duration","speedBps","avg_speed_mbps","parseFloat","url","response","ok","errorData","catch","String","thumbnailFile","getVideoStatus","listVideos","videos","style","primaryColor","secondaryColor","darkMode","width","height","showTitle","showDescription","embedUrl","params","React","createElement","src","frameBorder","allow","allowFullScreen","async","enable","window","localStorage","setItem","disable","removeItem"],"mappings":"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"}