{"version":3,"file":"videonest-sdk.umd.js","sources":["../src/utils/debug.ts","../src/utils/helpers.ts","../src/utils/uploadOptimizationManager.ts","../src/core/client.ts","../src/components/VideonestEmbed.tsx","../src/components/VideonestPreview.tsx","../src/index.ts"],"sourcesContent":["// src/utils/debug.ts\nimport debugModule from 'debug';\n\n// Debug mode configuration (disabled by default)\nlet isDebugEnabled: boolean = false;\n\n// Initialize debug module but don't enable by default\nconst debugInstance = debugModule('videonest-sdk');\n\n/**\n * Enable or disable debug mode for the SDK\n * @param enable Whether to enable debugging (true) or disable it (false)\n */\nexport function setDebugMode(enable: boolean): void {\n  isDebugEnabled = enable;\n  \n  if (enable) {\n    // Enable debug module\n    debugModule.enable('videonest-sdk');\n    \n    // Set localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem('debug', 'videonest-sdk');\n    }\n  } else {\n    // Disable debug module\n    debugModule.disable();\n    \n    // Clear localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.removeItem('debug');\n    }\n  }\n}\n\n/**\n * Get current debug mode status\n * @returns Boolean indicating if debug mode is enabled\n */\nexport function isDebugModeEnabled(): boolean {\n  return isDebugEnabled;\n}\n\n/**\n * Log messages only when debug mode is enabled\n */\nexport const log = function(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    debugInstance(message, ...args);\n  }\n};\n\n/**\n * Log messages that should always appear in console when debug mode is enabled,\n * or stay silent when debug mode is disabled\n */\nexport function forceLog(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    console.log(`[videonest-sdk] ${message}`, ...args);\n    debugInstance(message, ...args);\n  }\n}"," \nexport function generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }","// uploadOptimizationManager.ts - SDK v2 Upgrade\nimport { generateUUID } from './helpers'\nimport { VideonestConfig, VideoMetadata } from '../types'\n\nexport function calculateOptimalChunkSize(fileSize: number): number {\n  let baseChunkSize: number;\n  if (fileSize < 50 * 1024 * 1024) baseChunkSize = 8 * 1024 * 1024;        // < 50MB: 8MB\n  else if (fileSize < 500 * 1024 * 1024) baseChunkSize = 25 * 1024 * 1024; // < 500MB: 25MB\n  else if (fileSize < 2 * 1024 * 1024 * 1024) baseChunkSize = 50 * 1024 * 1024; // < 2GB: 50MB\n  else baseChunkSize = 100 * 1024 * 1024; // 100MB\n  return Math.floor(baseChunkSize);\n}\n\nexport class ConnectionSpeedDetector {\n  private samples: number[] = [];\n  public avgSpeed: number | null = null;\n  \n  recordChunkUpload(chunkSize: number, uploadTime: number): number {\n    const speedMbps = (chunkSize * 8) / (uploadTime / 1000) / 1_000_000;\n    this.samples.push(speedMbps);\n    if (this.samples.length > 5) this.samples.shift();\n    this.avgSpeed = this.calculateWeightedAverage(this.samples);\n    return this.avgSpeed;\n  }\n  \n  private calculateWeightedAverage(samples: number[]): number {\n    if (samples.length === 0) return 0;\n    let weightedSum = 0;\n    let totalWeight = 0;\n    samples.forEach((speed, index) => {\n      const weight = index + 1;\n      weightedSum += speed * weight;\n      totalWeight += weight;\n    });\n    return weightedSum / totalWeight;\n  }\n}\n\nexport class UploadOptimizationManager {\n  private file: File;\n  private metadata: VideoMetadata;\n  private config: VideonestConfig;\n  private static readonly CONCURRENCY = 5;\n  \n  private uploadQueue: Array<{index: number; uploadId: string; retries: number; maxRetries: number}> = [];\n  private activeUploads = new Map();\n  private completedChunks = new Set<number>();\n  private failedChunks = new Set<number>();\n  private speedDetector = new ConnectionSpeedDetector();\n  private chunkSize: number;\n  private totalChunks: number;\n  private uploadId: string = '';\n  private chunkBytesUploaded = new Map<number, number>();\n  private totalBytesUploaded = 0;\n  private startTime: number = 0;\n  private lastProgressReport: number = 0;\n  \n  constructor(file: File, metadata: VideoMetadata, config: VideonestConfig) {\n    this.file = file;\n    this.metadata = metadata;\n    this.config = config;\n    this.chunkSize = calculateOptimalChunkSize(file.size);\n    this.totalChunks = Math.ceil(file.size / this.chunkSize);\n    console.log(`ðŸš€ SDK Upload manager initialized: ${this.totalChunks} chunks, ${UploadOptimizationManager.CONCURRENCY} concurrency, ${(this.chunkSize / 1024 / 1024).toFixed(1)}MB chunk size`);\n  }\n  \n  async upload(onProgress: (progress: number, status: 'uploading' | 'finalizing' | 'failed') => void): Promise<{ uploadId: string; totalChunks: number }> {\n    const uploadId = generateUUID();\n    this.uploadId = uploadId;\n    this.startTime = Date.now();\n    onProgress(0, 'uploading');\n    \n    for (let i = 0; i < this.totalChunks; i++) this.chunkBytesUploaded.set(i, 0);\n    for (let i = 0; i < this.totalChunks; i++) this.uploadQueue.push({index: i, uploadId, retries: 0, maxRetries: 3});\n    \n    const workerPromises = [];\n    for (let i = 0; i < UploadOptimizationManager.CONCURRENCY; i++) workerPromises.push(this.uploadWorker(onProgress));\n    \n    await Promise.all(workerPromises);\n    \n    if (this.failedChunks.size > 0) {\n      onProgress(0, 'failed');\n      throw new Error(`Failed to upload ${this.failedChunks.size} chunks after retries`);\n    }\n    \n    console.log(`âœ… SDK Upload completed in ${((Date.now() - this.startTime) / 1000).toFixed(1)}s`);\n    return { uploadId, totalChunks: this.totalChunks };\n  }\n  \n  private async uploadWorker(onProgress: (progress: number, status: 'uploading' | 'finalizing' | 'failed') => void): Promise<void> {\n    while (this.uploadQueue.length > 0 || this.activeUploads.size > 0) {\n      if (this.uploadQueue.length > 0 && this.activeUploads.size < UploadOptimizationManager.CONCURRENCY) {\n        const chunkInfo = this.uploadQueue.shift();\n        if (chunkInfo) {\n          try {\n            await this.uploadChunk(chunkInfo, onProgress);\n          } catch (error) {\n            this.handleChunkError(chunkInfo, error as Error);\n          }\n        }\n      } else {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    }\n  }\n  \n  private async uploadChunk(chunkInfo: any, onProgress: (progress: number, status: 'uploading' | 'finalizing' | 'failed') => void): Promise<any> {\n    const { index, uploadId } = chunkInfo;\n    const start = index * this.chunkSize;\n    const end = Math.min(start + this.chunkSize, this.file.size);\n    const chunk = this.file.slice(start, end);\n    const chunkSize = chunk.size;\n    \n    if (chunkSize === 0) throw new Error(`Empty chunk detected for index ${index}`);\n    \n    this.activeUploads.set(index, { ...chunkInfo, startTime: Date.now() });\n    \n    const formData = new FormData();\n    formData.append('chunk', chunk);\n    formData.append('uploadId', uploadId);\n    formData.append('chunkIndex', index.toString());\n    formData.append('totalChunks', this.totalChunks.toString());\n    \n    const startTime = Date.now();\n    const baseUrl = this.config.baseUrl || 'https://api1.videonest.co';\n    \n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.timeout = 1800000;\n      \n      xhr.upload.onprogress = (event) => {\n        if (event.lengthComputable) {\n          this.chunkBytesUploaded.set(index, event.loaded);\n          this.totalBytesUploaded = Array.from(this.chunkBytesUploaded.values()).reduce((sum, bytes) => sum + bytes, 0);\n          const now = Date.now();\n          if (now - this.lastProgressReport > 100) {\n            const progressPercentage = (this.totalBytesUploaded / this.file.size) * 100;\n            onProgress(progressPercentage, 'uploading');\n            this.lastProgressReport = now;\n          }\n        }\n      };\n      \n      xhr.open('POST', `${baseUrl}/sdk/${this.config.channelId}/upload-chunk-v2`);\n      xhr.setRequestHeader('Authorization', `Bearer ${this.config.apiKey}`);\n      \n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const result = JSON.parse(xhr.responseText);\n            if (!result.success) {\n              reject(new Error(result.message || 'Chunk upload failed'));\n            } else {\n              const uploadTime = Date.now() - startTime;\n              this.speedDetector.recordChunkUpload(chunkSize, uploadTime);\n              this.activeUploads.delete(index);\n              this.completedChunks.add(index);\n              this.chunkBytesUploaded.set(index, chunkSize);\n              resolve(result);\n            }\n          } catch (e) {\n            reject(new Error('Invalid response from server'));\n          }\n        } else {\n          reject(new Error(`HTTP error: ${xhr.status}`));\n        }\n      };\n      \n      xhr.onerror = () => reject(new Error('Network error during upload'));\n      xhr.ontimeout = () => reject(new Error('Upload timeout - chunk may be too large'));\n      xhr.send(formData);\n    });\n  }\n  \n  private handleChunkError(chunkInfo: any, error: Error): void {\n    console.error(`Chunk ${chunkInfo.index} upload failed:`, error.message);\n    if (chunkInfo.retries < chunkInfo.maxRetries) {\n      chunkInfo.retries++;\n      setTimeout(() => {\n        this.uploadQueue.unshift(chunkInfo);\n      }, Math.pow(2, chunkInfo.retries) * 1000);\n    } else {\n      this.failedChunks.add(chunkInfo.index);\n      this.activeUploads.delete(chunkInfo.index);\n    }\n  }\n  \n  getUploadStats() {\n    return {\n      totalChunks: this.totalChunks,\n      completedChunks: this.completedChunks.size,\n      failedChunks: this.failedChunks.size,\n      activeUploads: this.activeUploads.size,\n      chunkSize: this.chunkSize,\n      totalSize: this.file.size,\n      averageSpeed: this.speedDetector.avgSpeed\n    };\n  }\n  \n  getTotalChunks(): number {\n    return this.totalChunks;\n  }\n}","import { VideonestConfig, VideoMetadata, UploadOptions, UploadResult, VideoStatus } from '../types';\nimport { log, forceLog } from '../utils/debug';\nimport { generateUUID } from '../utils/helpers';\nimport { UploadOptimizationManager } from '../utils/uploadOptimizationManager';\n\nexport default class VideonestClient {\n  private config: VideonestConfig;\n\n  constructor(config: VideonestConfig) {\n    this.config = config;\n    log('VideonestClient initialized with channelId:', config.channelId);\n  }\n  \n  async uploadVideo(file: File, options: UploadOptions): Promise<UploadResult> {\n    forceLog('Starting optimized video upload process');\n    forceLog(`File: ${file.name}, size: ${file.size} bytes`);\n    \n    // Generate a unique session ID for tracking\n    const sessionId = generateUUID();\n    const startTime = Date.now();\n    \n    try {\n      const { \n        metadata, \n        onProgress = (_progress: number, _status: 'uploading' | 'finalizing' | 'failed' | 'stalled') => {}, \n        thumbnail\n      } = options;\n      \n      // Check if thumbnail is provided\n      if (!thumbnail) {\n        forceLog('Error: Thumbnail is required');\n        onProgress(0, 'failed');\n        \n        // Track failed upload (missing thumbnail)\n        await this.trackVideoUpload('failed', {\n          sessionId,\n          startTime,\n          status: 'failed',\n          filename: file.name,\n          fileSize: file.size,\n          chunksCount: 0,\n        });\n        \n        throw new Error('Thumbnail is required for video upload');\n      }\n      \n      forceLog('Upload options:', { \n        metadata, \n        hasThumbnail: !!thumbnail\n      });\n      \n      // Make sure channelId is included in metadata\n      const uploadMetadata = {...metadata, channelId: this.config.channelId};\n      forceLog('Upload metadata:', uploadMetadata);\n      \n      // Create upload optimization manager\n      const uploadManager = new UploadOptimizationManager(\n        file, \n        uploadMetadata, \n        this.config\n      );\n      \n      // Get actual number of chunks based on optimal chunk size calculation\n      const actualChunks = uploadManager.getTotalChunks();\n      \n      // Start tracking upload session with actual chunk count\n      await this.trackVideoUpload('start', {\n        sessionId,\n        startTime,\n        userId: 'sdk-user', // Use generic user ID for SDK uploads\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: actualChunks, // Use actual calculated chunks, not default 2MB chunks\n        status: 'in_progress'\n      });\n      \n      // Upload chunks with optimization\n      const { uploadId, totalChunks } = await uploadManager.upload(onProgress);\n      \n      // Set status to finalizing once chunks are done\n      onProgress(100, 'finalizing');\n      \n      forceLog(`All chunks uploaded. Finalizing upload... (uploadId: ${uploadId}, totalChunks: ${totalChunks})`);\n\n      const finalData = { \n        fileName: file.name, \n        uploadId: uploadId,\n        totalChunks: totalChunks.toString(),\n        title: uploadMetadata.title || 'Untitled Video',\n        description: uploadMetadata.description || '',\n        tags: uploadMetadata.tags ? (Array.isArray(uploadMetadata.tags) ? uploadMetadata.tags.join(',') : uploadMetadata.tags) : ''\n      };\n      forceLog('Finalize request data:', finalData);\n      \n      // Use new SDK v2 finalize route\n      const finalizeResponse = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/finalize-v2`, {\n        method: 'POST',\n        body: JSON.stringify(finalData),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      forceLog(`Finalize response status: ${finalizeResponse.status}`);\n      const finalizeResult = await finalizeResponse.json();\n      forceLog('Finalize response data:', finalizeResult);\n      \n      if (!finalizeResult.success) {\n        forceLog(`Finalization failed: ${finalizeResult.message}`);\n        onProgress(100, 'failed');\n        \n        // Track failed upload (finalization failed)\n        await this.trackVideoUpload('failed', {\n          sessionId,\n          startTime,\n          status: 'failed',\n          filename: file.name,\n          fileSize: file.size,\n          chunksCount: totalChunks,\n          videoId: finalizeResult.video?.id || 0\n        });\n        \n        throw new Error(finalizeResult.message || 'Upload finalization failed');\n      }\n      \n      forceLog('Upload successfully finalized');\n      \n      // Track successful upload completion before thumbnail upload\n      await this.trackVideoUpload('complete', {\n        sessionId,\n        startTime,\n        status: 'complete',\n        filename: file.name,\n        fileSize: file.size,\n        chunksCount: totalChunks,\n        videoId: finalizeResult.video.id\n      });\n      \n      // Upload the provided thumbnail\n      forceLog('Uploading user-provided thumbnail');\n      await this.uploadThumbnail(thumbnail, finalizeResult.video.id);\n      forceLog('Upload process completed successfully');\n      \n      return finalizeResult;\n    } catch (error) {\n      forceLog(`Upload error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      options.onProgress?.(0, 'failed');\n      await this.trackVideoUpload('failed', {\n        sessionId,\n        startTime,\n        status: 'failed',\n        filename: file.name,\n        fileSize: file.size\n      });\n      \n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'An unexpected error occurred during upload' \n      };\n    }\n  }\n\n  // correct endpoint \n  private async trackVideoUpload(action: string, sessionData: any) {\n    log(\"Tracking video upload:\", action, sessionData);\n    \n    try {\n      let endpoint = '';\n      let method = 'POST';\n      let requestBody: any;\n      const baseUrl = 'https://api1.videonest.co';\n  \n      if (action === 'start') {\n        // CREATE new session\n        endpoint = '/video-stats/upload-sessions';\n        method = 'POST';\n        requestBody = {\n          session_id: sessionData.sessionId,\n          user_id: sessionData.userId,\n          video_id: sessionData.videoId || 0, // Will be updated later\n          filename: sessionData.filename,\n          file_size: sessionData.fileSize,\n          chunks_count: sessionData.chunksCount || 0,\n          status: 'in_progress'\n        };\n      } else if (action === 'complete' || action === 'failed') {\n        // UPDATE existing session\n        endpoint = `/video-stats/upload-sessions/${sessionData.sessionId}`;\n        method = 'POST'; // API uses POST for updates\n        requestBody = {\n          video_id: sessionData.videoId,\n          end_time: new Date().toISOString(),\n          status: sessionData.status\n        };\n        if (sessionData.startTime) {\n          const duration = Date.now() - sessionData.startTime;\n          requestBody.total_duration = `${Math.floor(duration / 1000)} seconds`;\n          if (sessionData.fileSize && duration > 0) {\n            const speedBps = (sessionData.fileSize * 8) / (duration / 1000); // bits per second\n            requestBody.avg_speed_mbps = parseFloat((speedBps / 1_000_000).toFixed(2)); // Convert to Mbps\n          }\n        }\n      }\n  \n      const url = `${baseUrl}${endpoint}`;\n      const headers: Record<string, string> = {'Content-Type': 'application/json'};\n      const response = await fetch(url, {method, headers, body: JSON.stringify(requestBody)});\n  \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        log('Failed to track upload session:', errorData);\n        return { success: false, error: 'Failed to track upload session' };\n      }\n      const data = await response.json();\n      return { success: true, ...data };\n    } catch (error) {\n      log('Error tracking upload session:', error instanceof Error ? error.message : String(error));\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to track upload session' };\n    }\n  }\n\n\n  private async uploadThumbnail(thumbnailFile: File, videoId: string): Promise<any> {\n    \n    const formData = new FormData();\n    formData.append('thumbnail', thumbnailFile);\n\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/send-thumbnail`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Thumbnail upload failed');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to upload thumbnail');\n    }\n  }\n  \n\n\n async getVideoStatus(videoId: number): Promise<VideoStatus> {\n    \n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/status`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to get video status');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to get video status');\n    }\n  }\n\n\n\n\n  async listVideos(): Promise<{ success: boolean, videos?: any[], message?: string }> {\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n      \n      log(`Videos list response status: ${response.status}`);\n      const result = await response.json();\n      log('Videos list response data:', result);\n      \n      if (!result.success) {\n        log(`Videos list fetch failed: ${result.message || 'Unknown error'}`);\n        return {\n          success: false,\n          message: result.message || 'Failed to retrieve videos'\n        };\n      }\n      \n      log(`Successfully retrieved ${result.videos ? result.videos.length : 0} videos`);\n      return result;\n    } catch (error) {\n      log(`Videos list error: ${error instanceof Error ? error.message : 'Unknown error'}`, error);\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Failed to retrieve videos'\n      };\n    }\n  }\n\n\n\n\n}","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestEmbedProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestEmbed: React.FC<VideonestEmbedProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/single/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestEmbed;","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestPreviewProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestPreview: React.FC<VideonestPreviewProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/preview/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  // new version\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestPreview;","import { log, forceLog, setDebugMode, isDebugModeEnabled } from './utils/debug';\nimport VideonestClient from './core/client';\nimport { VideonestConfig } from './types';\nimport VideonestEmbed from './components/VideonestEmbed';\nimport VideonestPreview from './components/VideonestPreview';\n\nexport * from './types';\nexport { setDebugMode, isDebugModeEnabled } from './utils/debug';\n\nexport { VideonestEmbed }; // Export the component\nexport { VideonestPreview }; // Export the component\n/**\n * Upload a video to VideoNest\n * @param file The video file to upload\n * @param options Upload options including metadata\n * @param config VideoNest configuration with channelId and apiKey\n */\n// Minor\nexport async function uploadVideo(file: File, options: any, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.uploadVideo(file, options);\n}\n\n/**\n * Get the status of a video\n * @param videoId The ID of the video to check status\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function getVideoStatus(videoId: number, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.getVideoStatus(videoId);\n}\n\n/**\n * List all videos for the channel\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function listVideos(config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.listVideos();\n}\n\n"],"names":["isDebugEnabled","debugInstance","debugModule","log","message","args","forceLog","console","generateUUID","replace","c","r","Math","random","toString","ConnectionSpeedDetector","constructor","this","samples","avgSpeed","recordChunkUpload","chunkSize","uploadTime","speedMbps","push","length","shift","calculateWeightedAverage","weightedSum","totalWeight","forEach","speed","index","weight","UploadOptimizationManager","file","metadata","config","uploadQueue","activeUploads","Map","completedChunks","Set","failedChunks","speedDetector","uploadId","chunkBytesUploaded","totalBytesUploaded","startTime","lastProgressReport","fileSize","baseChunkSize","floor","calculateOptimalChunkSize","size","totalChunks","ceil","CONCURRENCY","toFixed","upload","onProgress","Date","now","i","set","retries","maxRetries","workerPromises","uploadWorker","Promise","all","Error","chunkInfo","uploadChunk","error","handleChunkError","resolve","setTimeout","start","end","min","chunk","slice","formData","FormData","append","baseUrl","reject","xhr","XMLHttpRequest","timeout","onprogress","event","lengthComputable","loaded","Array","from","values","reduce","sum","bytes","progressPercentage","open","channelId","setRequestHeader","apiKey","onload","status","result","JSON","parse","responseText","success","delete","add","e","onerror","ontimeout","send","unshift","pow","getUploadStats","totalSize","averageSpeed","getTotalChunks","VideonestClient","uploadVideo","options","name","sessionId","_progress","_status","thumbnail","trackVideoUpload","filename","chunksCount","hasThumbnail","uploadMetadata","uploadManager","actualChunks","userId","finalData","fileName","title","description","tags","isArray","join","finalizeResponse","fetch","method","body","stringify","headers","Authorization","finalizeResult","json","videoId","_a","video","id","uploadThumbnail","_b","call","action","sessionData","requestBody","endpoint","session_id","user_id","video_id","file_size","chunks_count","end_time","toISOString","duration","total_duration","speedBps","avg_speed_mbps","parseFloat","url","response","ok","errorData","catch","String","thumbnailFile","getVideoStatus","listVideos","videos","style","primaryColor","secondaryColor","darkMode","width","height","showTitle","showDescription","embedUrl","params","React","createElement","src","frameBorder","allow","allowFullScreen","async","enable","window","localStorage","setItem","disable","removeItem"],"mappings":"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"}