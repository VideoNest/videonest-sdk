{"version":3,"file":"videonest-sdk.umd.js","sources":["../src/core/client.ts","../src/index.ts"],"sourcesContent":["import { VideonestConfig, VideoMetadata, UploadOptions, UploadResult, AuthResponse, VideoStatus } from '../types';\n\n// Conditionally import fluent-ffmpeg for Node environments\nlet ffmpeg: any;\nif (typeof window === 'undefined') {\n  // This will only execute in Node.js environments\n  ffmpeg = require('fluent-ffmpeg');\n}\n\nexport default class VideonestClient {\n  private config: VideonestConfig;\n  private authenticated: boolean = false;\n\n  constructor(config: VideonestConfig) {\n    this.config = config;\n  }\n\n  async authenticate(): Promise<AuthResponse> {\n    try {\n      const response = await fetch('https://api1.videonest.co/auth/verify-api-key', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          channelId: this.config.channelId,\n          apiKey: this.config.apiKey\n        }),\n      });\n      \n      const data = await response.json();\n      \n      if (!data.success) {\n        this.authenticated = false;\n        return {\n          success: false,\n          message: data.message || 'Authentication failed'\n        };\n      }\n      \n      this.authenticated = true;\n      return {\n        success: true,\n        message: 'Authentication successful'\n      };\n    } catch (error) {\n      this.authenticated = false;\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Authentication failed'\n      };\n    }\n  }\n  \n  async uploadVideo(file: File, options: UploadOptions): Promise<UploadResult> {\n    this.checkAuthentication();\n    \n    try {\n      const { \n        metadata, \n        chunkSize = 2 * 1024 * 1024, \n        onProgress = () => {}, \n        thumbnail,\n        autoGenerateThumbnail = false\n      } = options;\n      \n      // Generate UUID for this upload\n      const uploadId = this.generateUUID();\n      const totalChunks = Math.ceil(file.size / chunkSize);\n      \n      // Make sure channelId is included in metadata\n      const uploadMetadata = {\n        ...metadata,\n        channelId: metadata.channelId || this.config.channelId,\n      };\n      \n      // Upload file in chunks\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * chunkSize;\n        const end = Math.min(start + chunkSize, file.size);\n        const chunk = file.slice(start, end);\n        \n        const formData = new FormData();\n        formData.append('chunk', chunk);\n        formData.append('uploadId', uploadId);\n        formData.append('chunkIndex', chunkIndex.toString());\n        formData.append('totalChunks', totalChunks.toString());\n        formData.append('fileName', file.name);\n        formData.append('fileSize', file.size.toString());\n        \n        // Add metadata to the first chunk\n        if (chunkIndex === 0 && uploadMetadata) {\n          formData.append('channelId', uploadMetadata.channelId.toString());\n          if (uploadMetadata.title) formData.append('title', uploadMetadata.title);\n          if (uploadMetadata.description) formData.append('description', uploadMetadata.description);\n          \n          if (uploadMetadata.tags) {\n            // Handle tags that could be either string or array\n            const tagsValue = Array.isArray(uploadMetadata.tags) \n              ? uploadMetadata.tags.join(',') \n              : uploadMetadata.tags;\n              \n            if (tagsValue && tagsValue.length > 0) {\n              formData.append('tags', tagsValue);\n            }\n          }\n        }\n        \n        // Send the chunk\n        const response = await fetch('https://api1.videonest.co/upload/videos/upload-chunk', {\n          method: 'POST',\n          body: formData,\n          headers: {\n            'Authorization': `Bearer ${this.config.apiKey}`,\n          },\n        });\n        \n        const result = await response.json();\n        if (!result.success) {\n          throw new Error(result.message || 'Chunk upload failed');\n        }\n        \n        // Update progress\n        const progress = ((chunkIndex + 1) / totalChunks) * 100;\n        onProgress(progress);\n      }\n      \n      // Finalize the upload\n      const finalData = { \n        fileName: file.name, \n        uploadId: uploadId,\n        totalChunks: totalChunks.toString() \n      };\n      \n      const finalizeResponse = await fetch('https://api1.videonest.co/videos/finalize', {\n        method: 'POST',\n        body: JSON.stringify(finalData),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`,\n        },\n      });\n      \n      const finalizeResult = await finalizeResponse.json();\n      if (!finalizeResult.success) {\n        throw new Error(finalizeResult.message || 'Upload finalization failed');\n      }\n      \n      // Handle thumbnail\n      if (thumbnail) {\n        // User provided a thumbnail, upload it directly\n        await this.uploadThumbnail(uploadMetadata.channelId, thumbnail, finalizeResult.video.id);\n      } else if (autoGenerateThumbnail) {\n        // User wants an auto-generated thumbnail\n        try {\n          const generatedThumbnail = await this.createThumbnailFromVideo(file);\n          await this.uploadThumbnail(uploadMetadata.channelId, generatedThumbnail, finalizeResult.video.id);\n        } catch (thumbnailError) {\n          console.warn('Failed to generate thumbnail:', thumbnailError);\n          // Continue without thumbnail rather than failing the whole upload\n        }\n      }\n      \n      return finalizeResult;\n    } catch (error) {\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'An unexpected error occurred during upload' \n      };\n    }\n  }\n\n  private checkAuthentication(): void {\n    if (!this.authenticated) {\n      throw new Error('Not authenticated. Call authenticate() first.');\n    }\n  }\n  \n  \n  private async uploadThumbnail(channelId: string, thumbnailFile: File, videoId: string): Promise<any> {\n    this.checkAuthentication();\n    \n    const formData = new FormData();\n    formData.append('thumbnail', thumbnailFile);\n\n    try {\n      const response = await fetch(`https://api1.videonest.co/download/videos/${videoId}/send-thumbnail`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Thumbnail upload failed');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to upload thumbnail');\n    }\n  }\n  \n \n  private generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n\n \n  private async createThumbnailFromVideo(videoFile: File): Promise<File> {\n    // Check if we're in a browser environment\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n      // Browser method using video and canvas\n      return this.createThumbnailInBrowser(videoFile);\n    } else {\n      // Node.js method using fluent-ffmpeg\n      return this.createThumbnailInNode(videoFile);\n    }\n  }\n\n \n  private async createThumbnailInBrowser(videoFile: File): Promise<File> {\n    return new Promise((resolve, reject) => {\n      // Create video element\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n      video.muted = true;\n      video.playsInline = true;\n      \n      // Create object URL from the video file\n      const videoUrl = URL.createObjectURL(videoFile);\n      video.src = videoUrl;\n      \n      // Set up event handlers\n      video.onloadedmetadata = () => {\n        // Seek to the 2 second mark (or video duration if less than 2 seconds)\n        video.currentTime = Math.min(2, video.duration);\n      };\n      \n      video.onseeked = () => {\n        try {\n          // Create canvas with video dimensions\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n          \n          if (!ctx) {\n            reject(new Error('Failed to get canvas context'));\n            return;\n          }\n          \n          // Set canvas dimensions to match video\n          canvas.width = video.videoWidth;\n          canvas.height = video.videoHeight;\n          \n          // Draw the current frame to the canvas\n          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n          \n          // Convert canvas to blob\n          canvas.toBlob((blob) => {\n            if (!blob) {\n              reject(new Error('Failed to create thumbnail blob'));\n              return;\n            }\n            \n            // Clean up\n            URL.revokeObjectURL(videoUrl);\n            \n            // Create a File from the Blob\n            const thumbnailFile = new File(\n              [blob], \n              `${videoFile.name.split('.')[0]}_thumbnail.jpg`, \n              { type: 'image/jpeg' }\n            );\n            \n            resolve(thumbnailFile);\n          }, 'image/jpeg', 0.95);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      \n      video.onerror = () => {\n        URL.revokeObjectURL(videoUrl);\n        reject(new Error('Error loading video for thumbnail generation'));\n      };\n      \n      // Start loading\n      video.load();\n    });\n  }\n\n \n  private async createThumbnailInNode(videoFile: File): Promise<File> {\n    return new Promise((resolve, reject) => {\n      if (!ffmpeg) {\n        reject(new Error('fluent-ffmpeg is required for Node.js thumbnail generation. Install it with: npm install fluent-ffmpeg'));\n        return;\n      }\n\n      // Create a temporary file path\n      const os = require('os');\n      const path = require('path');\n      const fs = require('fs');\n      \n      const tempDir = os.tmpdir();\n      const inputPath = path.join(tempDir, videoFile.name);\n      const outputPath = path.join(tempDir, `${path.parse(videoFile.name).name}_thumbnail.jpg`);\n      \n      // Write the file to disk\n      fs.writeFileSync(inputPath, Buffer.from(videoFile as any));\n      \n      // Use ffmpeg to extract the frame at 2 seconds\n      ffmpeg(inputPath)\n        .screenshots({\n          timestamps: [2],\n          filename: path.basename(outputPath),\n          folder: path.dirname(outputPath),\n          size: '?x?'  // Keep original dimensions\n        })\n        .on('end', () => {\n          try {\n            // Read the thumbnail file\n            const thumbnailBuffer = fs.readFileSync(outputPath);\n            \n            // Create a File object from the buffer\n            const thumbnailFile = new File(\n              [thumbnailBuffer], \n              path.basename(outputPath), \n              { type: 'image/jpeg' }\n            );\n            \n            // Clean up temp files\n            fs.unlinkSync(inputPath);\n            fs.unlinkSync(outputPath);\n            \n            resolve(thumbnailFile);\n          } catch (error) {\n            reject(error);\n          }\n        })\n        .on('error', (err: Error) => {\n          // Clean up temp file\n          if (fs.existsSync(inputPath)) {\n            fs.unlinkSync(inputPath);\n          }\n          reject(err);\n        });\n    });\n  }\n\n async getVideoStatus(videoId: number): Promise<VideoStatus> {\n    this.checkAuthentication();\n    \n    try {\n      const response = await fetch(`https://api1.videonest.co/videos/${videoId}/status`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n        },\n      });\n      \n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to get video status');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to get video status');\n    }\n  }\n}","// Main entry point for the Videonest SDK\nimport VideonestClient from './core/client';\nimport { AuthResponse } from './types';\n\nexport * from './types';\n\n// Global client instance\nlet clientInstance: VideonestClient | null = null;\n\n\nexport async function authVideonest(\n  channelId: string, \n  apiKey: string\n): Promise<AuthResponse> {\n  clientInstance = new VideonestClient({\n    channelId,\n    apiKey\n  });\n  \n  return await clientInstance.authenticate();\n}\n\n\nexport function getClient(): VideonestClient {\n  if (!clientInstance) {\n    throw new Error('SDK not initialized. Call authVideonest() first.');\n  }\n  \n  return clientInstance;\n}\n\n\nexport async function uploadVideo(file: File, options: any) {\n  return getClient().uploadVideo(file, options);\n}\n\nexport async function getVideoStatus(videoId: number) {\n    return getClient().getVideoStatus(videoId);\n  }\n\nexport { VideonestClient };"],"names":["ffmpeg","window","require","VideonestClient","constructor","config","this","authenticated","authenticate","response","fetch","method","headers","body","JSON","stringify","channelId","apiKey","data","json","success","message","error","Error","uploadVideo","file","options","checkAuthentication","metadata","chunkSize","onProgress","thumbnail","autoGenerateThumbnail","uploadId","generateUUID","totalChunks","Math","ceil","size","uploadMetadata","chunkIndex","start","end","min","chunk","slice","formData","FormData","append","toString","name","title","description","tags","tagsValue","Array","isArray","join","length","Authorization","result","finalData","fileName","finalizeResponse","finalizeResult","uploadThumbnail","video","id","generatedThumbnail","createThumbnailFromVideo","thumbnailError","console","warn","thumbnailFile","videoId","replace","c","r","random","videoFile","document","createThumbnailInBrowser","createThumbnailInNode","Promise","resolve","reject","createElement","preload","muted","playsInline","videoUrl","URL","createObjectURL","src","onloadedmetadata","currentTime","duration","onseeked","canvas","ctx","getContext","width","videoWidth","height","videoHeight","drawImage","toBlob","blob","revokeObjectURL","File","split","type","onerror","load","os","path","fs","tempDir","tmpdir","inputPath","outputPath","parse","writeFileSync","Buffer","from","screenshots","timestamps","filename","basename","folder","dirname","on","thumbnailBuffer","readFileSync","unlinkSync","err","existsSync","getVideoStatus","clientInstance","getClient","async"],"mappings":"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"}