{"version":3,"file":"videonest-sdk.umd.js","sources":["../src/utils/debug.ts","../src/core/client.ts","../src/components/VideonestEmbed.tsx","../src/components/VideonestPreview.tsx","../src/index.ts"],"sourcesContent":["// src/utils/debug.ts\nimport debugModule from 'debug';\n\n// Debug mode configuration (disabled by default)\nlet isDebugEnabled: boolean = true;\n\n// Initialize debug module but don't enable by default\nconst debugInstance = debugModule('videonest-sdk');\n\n/**\n * Enable or disable debug mode for the SDK\n * @param enable Whether to enable debugging (true) or disable it (false)\n */\nexport function setDebugMode(enable: boolean): void {\n  isDebugEnabled = enable;\n  \n  if (enable) {\n    // Enable debug module\n    debugModule.enable('videonest-sdk');\n    \n    // Set localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem('debug', 'videonest-sdk');\n    }\n  } else {\n    // Disable debug module\n    debugModule.disable();\n    \n    // Clear localStorage if in browser environment\n    if (typeof window !== 'undefined') {\n      window.localStorage.removeItem('debug');\n    }\n  }\n}\n\n/**\n * Get current debug mode status\n * @returns Boolean indicating if debug mode is enabled\n */\nexport function isDebugModeEnabled(): boolean {\n  return isDebugEnabled;\n}\n\n/**\n * Log messages only when debug mode is enabled\n */\nexport const log = function(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    debugInstance(message, ...args);\n  }\n};\n\n/**\n * Log messages that should always appear in console when debug mode is enabled,\n * or stay silent when debug mode is disabled\n */\nexport function forceLog(message: string, ...args: any[]): void {\n  if (isDebugEnabled) {\n    console.log(`[videonest-sdk] ${message}`, ...args);\n    debugInstance(message, ...args);\n  }\n}","import { VideonestConfig, VideoMetadata, UploadOptions, UploadResult, VideoStatus } from '../types';\nimport { log, forceLog } from '../utils/debug';\nimport { generateUUID } from '../utils/helpers';\n\nexport default class VideonestClient {\n  private config: VideonestConfig;\n\n  constructor(config: VideonestConfig) {\n    this.config = config;\n    log('VideonestClient initialized with channelId:', config.channelId);\n  }\n\n  /**\n   * Upload video directly to S3 using presigned URLs\n   */\n  private async uploadToS3(\n    file: File,\n    presignedUrls: string[],\n    uploadId: string,\n    s3Key: string,\n    chunkSize: number,\n    onProgress: (progress: number) => void\n  ): Promise<{ success: boolean; uploadId: string; s3Key: string; parts: any[]; error?: string }> {\n    try {\n      const totalParts = presignedUrls.length;\n      const uploadedParts: any[] = [];\n\n      log(`üöÄ Starting S3 upload: ${file.name} (${totalParts} parts)`);\n\n      // Track progress for each chunk\n      const chunkProgress = new Array(totalParts).fill(0);\n\n      const updateOverallProgress = () => {\n        const totalProgress = chunkProgress.reduce((sum, progress) => sum + progress, 0);\n        const overallProgress = totalProgress / totalParts;\n        onProgress(overallProgress);\n      };\n\n      // Upload chunks with controlled concurrency (max 6 chunks at a time)\n      const CONCURRENT_CHUNKS = 6;\n      const MAX_RETRIES = 3;\n      const activeChunks = new Set();\n      const completedParts: any[] = [];\n\n      const uploadChunk = async (index: number, retryCount = 0): Promise<{ PartNumber: number; ETag: string }> => {\n        const presignedUrl = presignedUrls[index];\n        const start = index * chunkSize;\n        const end = Math.min(start + chunkSize, file.size);\n        const chunk = file.slice(start, end);\n\n        // Reset progress for this chunk (fixes retry progress calculation)\n        chunkProgress[index] = 0;\n        updateOverallProgress();\n\n        if (chunk.size === 0) {\n          throw new Error(`Empty chunk detected for part ${index + 1}`);\n        }\n\n        return new Promise<{ PartNumber: number; ETag: string }>((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          xhr.timeout = 60000; // 1 minute timeout (reduced from 5 minutes)\n\n          xhr.upload.onprogress = (event) => {\n            if (event.lengthComputable) {\n              chunkProgress[index] = (event.loaded / event.total) * 100;\n              updateOverallProgress();\n            }\n          };\n\n          xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n              const etag = xhr.getResponseHeader('ETag');\n              if (!etag) {\n                reject(new Error(`No ETag received for part ${index + 1}`));\n                return;\n              }\n\n              chunkProgress[index] = 100;\n              updateOverallProgress();\n              log(`‚úÖ Chunk ${index + 1}/${totalParts} completed`);\n\n              resolve({\n                PartNumber: index + 1,\n                ETag: etag.replace(/\"/g, '')\n              });\n            } else {\n              reject(new Error(`HTTP ${xhr.status}: Failed to upload part ${index + 1}`));\n            }\n          };\n\n          xhr.onerror = () => reject(new Error(`Network error uploading part ${index + 1}`));\n          xhr.ontimeout = () => reject(new Error(`Timeout uploading part ${index + 1}`));\n\n          xhr.open('PUT', presignedUrl);\n          xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n          xhr.send(chunk);\n        }).catch(async (error) => {\n          // Retry logic\n          if (retryCount < MAX_RETRIES) {\n            log(`‚ö†Ô∏è Chunk ${index + 1} failed, retrying (${retryCount + 1}/${MAX_RETRIES}): ${error.message}`);\n            await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000)); // Exponential backoff\n            return uploadChunk(index, retryCount + 1);\n          } else {\n            log(`‚ùå Chunk ${index + 1} failed after ${MAX_RETRIES} retries: ${error.message}`);\n            throw error;\n          }\n        });\n      };\n\n      // Process chunks with controlled concurrency\n      for (let i = 0; i < presignedUrls.length; i++) {\n        // Wait if we've hit the concurrency limit\n        if (activeChunks.size >= CONCURRENT_CHUNKS) {\n          await Promise.race(activeChunks);\n        }\n\n        const chunkPromise = uploadChunk(i)\n          .then(result => {\n            completedParts.push(result);\n            log(`üìä Progress: ${completedParts.length}/${totalParts} chunks completed (${Math.round((completedParts.length / totalParts) * 100)}%)`);\n            return result;\n          })\n          .catch(error => {\n            log(`üí• Chunk ${i + 1}/${totalParts} permanently failed: ${error.message}`);\n            throw error;\n          })\n          .finally(() => activeChunks.delete(chunkPromise));\n\n        activeChunks.add(chunkPromise);\n      }\n\n      // Wait for remaining chunks to complete\n      await Promise.all(activeChunks);\n\n      // Sort parts by part number to ensure correct order\n      const sortedParts = completedParts.sort((a, b) => a.PartNumber - b.PartNumber);\n\n      log(`‚úÖ S3 upload completed: ${file.name} (${sortedParts.length} parts)`);\n\n      return {\n        success: true,\n        uploadId: uploadId,\n        s3Key: s3Key,\n        parts: sortedParts\n      };\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to upload to S3';\n      log(`‚ùå S3 upload failed: ${errorMessage}`);\n      return {\n        success: false,\n        uploadId: uploadId,\n        s3Key: s3Key,\n        parts: [],\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Main video upload method\n   */\n  async uploadVideo(file: File, options: UploadOptions): Promise<UploadResult> {\n    forceLog(`üì§ Starting upload: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);\n\n    try {\n      const {\n        metadata,\n        onProgress = (_progress: number, _status: 'uploading' | 'finalizing' | 'failed' | 'stalled') => { },\n        thumbnail\n      } = options;\n\n      // Check if thumbnail is provided\n      if (!thumbnail) {\n        onProgress(0, 'failed');\n        throw new Error('Thumbnail is required for video upload');\n      }\n\n      // Make sure channelId is included in metadata\n      const uploadMetadata = { ...metadata, channelId: this.config.channelId };\n\n      // Step 1: Generate presigned URLs using SDK endpoint\n      const presignedResponse = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/generate-presigned-url`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n        body: JSON.stringify({\n          fileName: file.name,\n          fileSize: file.size,\n          contentType: file.type,\n          metadata: uploadMetadata\n        })\n      });\n\n      if (!presignedResponse.ok) {\n        throw new Error(`Failed to generate presigned URLs: ${presignedResponse.status}`);\n      }\n\n      const presignedData = await presignedResponse.json();\n\n      if (!presignedData.success) {\n        throw new Error(presignedData.error || 'Failed to generate presigned URLs');\n      }\n\n      onProgress(0, 'uploading');\n\n      const uploadResult = await this.uploadToS3(\n        file,\n        presignedData.presignedUrls,\n        presignedData.uploadId,\n        presignedData.s3Key,\n        presignedData.chunkSize,\n        (progress) => {\n          onProgress(progress, 'uploading');\n        }\n      );\n\n      if (!uploadResult.success) {\n        throw new Error(uploadResult.error || 'S3 upload failed');\n      }\n\n      onProgress(100, 'finalizing');\n\n      // Step 3: Complete upload using SDK endpoint\n      const completeResponse = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/complete-upload`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n        body: JSON.stringify({\n          uploadId: uploadResult.uploadId,\n          s3Key: uploadResult.s3Key,\n          parts: uploadResult.parts\n        })\n      });\n\n      if (!completeResponse.ok) {\n        throw new Error(`Failed to complete upload: ${completeResponse.status}`);\n      }\n\n      const completeData = await completeResponse.json();\n\n      if (!completeData.success) {\n        throw new Error(completeData.message || 'Upload completion failed');\n      }\n\n      // Step 4: Upload thumbnail using SDK endpoint\n      await this.uploadThumbnail(thumbnail, completeData.data.videoId);\n      forceLog('‚úÖ Upload completed successfully:', completeData.data.videoId);\n\n      return {\n        success: true,\n        message: 'Video uploaded successfully',\n        video: {\n          id: completeData.data.videoId,\n        }\n      };\n\n    } catch (error) {\n      forceLog(`‚ùå Upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'An unexpected error occurred during upload'\n      };\n    }\n  }\n\n  /**\n   * Upload thumbnail to the video\n   */\n  private async uploadThumbnail(thumbnailFile: File, videoId: string): Promise<any> {\n    const formData = new FormData();\n    formData.append('thumbnail', thumbnailFile);\n\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/send-thumbnail`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n\n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Thumbnail upload failed');\n      }\n\n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to upload thumbnail');\n    }\n  }\n\n  /**\n   * Get video status\n   */\n  async getVideoStatus(videoId: number): Promise<VideoStatus> {\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos/${videoId}/status`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n\n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to get video status');\n      }\n\n      return result;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : 'Failed to get video status');\n    }\n  }\n\n  /**\n   * List all videos in the channel\n   */\n  async listVideos(): Promise<{ success: boolean, videos?: any[], message?: string }> {\n    try {\n      const response = await fetch(`https://api1.videonest.co/sdk/${this.config.channelId}/videos`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`\n        },\n      });\n\n      const result = await response.json();\n\n      if (!result.success) {\n        return {\n          success: false,\n          message: result.message || 'Failed to retrieve videos'\n        };\n      }\n\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Failed to retrieve videos'\n      };\n    }\n  }\n}","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestEmbedProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestEmbed: React.FC<VideonestEmbedProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/single/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestEmbed;","import * as React from 'react';\nimport { VideonestConfig } from '../types';\nimport { log, forceLog } from '../utils/debug';\n\ninterface VideonestPreviewProps {\n  videoId: number;\n  config: VideonestConfig;\n  style?: {\n    secondaryColor?: string;\n    primaryColor?: string;\n    darkMode?: boolean;\n    width?: string | number;\n    height?: string | number;\n    showTitle?: boolean;\n    showDescription?: boolean;\n  };\n}\n\nconst VideonestPreview: React.FC<VideonestPreviewProps> = ({ videoId, config, style = {} }) => {\n  const { primaryColor, secondaryColor, darkMode, width, height, showTitle, showDescription } = style;\n\n  let embedUrl = `https://app.videonest.co/embed/preview/${videoId}`;\n  const params: string[] = [];\n\n  if (primaryColor) params.push(`primary_color=${primaryColor.replace('#', '')}`);\n  if (secondaryColor) params.push(`secondary_color=${secondaryColor.replace('#', '')}`);\n  if (darkMode) params.push('dark_mode=true');\n  if (showTitle) params.push('show_title=true');\n  if (showDescription) params.push('show_description=true');\n  \n  // Add authentication parameters\n  // new version\n  params.push(`channel_id=${config.channelId}`);\n  params.push(`api_key=${config.apiKey}`);\n\n  if (params.length > 0) {\n    embedUrl += `?${params.join('&')}`;\n  }\n\n  return (\n    <iframe\n        src={embedUrl}\n        style={{width: width || '100%', height: height || '100%'}}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n        title={`Videonest video ${videoId}`}\n      />\n  );\n};\n\nexport default VideonestPreview;","import { log, forceLog, setDebugMode, isDebugModeEnabled } from './utils/debug';\nimport VideonestClient from './core/client';\nimport { VideonestConfig } from './types';\nimport VideonestEmbed from './components/VideonestEmbed';\nimport VideonestPreview from './components/VideonestPreview';\n\nexport * from './types';\nexport { setDebugMode, isDebugModeEnabled } from './utils/debug';\n\nexport { VideonestEmbed }; // Export the component\nexport { VideonestPreview }; // Export the component\n/**\n * Upload a video to VideoNest\n * @param file The video file to upload\n * @param options Upload options including metadata\n * @param config VideoNest configuration with channelId and apiKey\n */\n// Minor\nexport async function uploadVideo(file: File, options: any, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.uploadVideo(file, options);\n}\n\n/**\n * Get the status of a video\n * @param videoId The ID of the video to check status\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function getVideoStatus(videoId: number, config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.getVideoStatus(videoId);\n}\n\n/**\n * List all videos for the channel\n * @param config VideoNest configuration with channelId and apiKey\n */\nexport async function listVideos(config: VideonestConfig) {\n  const client = new VideonestClient(config);\n  return client.listVideos();\n}\n\n"],"names":["isDebugEnabled","debugInstance","debugModule","log","message","args","forceLog","console","VideonestClient","constructor","config","this","channelId","uploadToS3","file","presignedUrls","uploadId","s3Key","chunkSize","onProgress","totalParts","length","name","chunkProgress","Array","fill","updateOverallProgress","totalProgress","reduce","sum","progress","CONCURRENT_CHUNKS","MAX_RETRIES","activeChunks","Set","completedParts","uploadChunk","async","index","retryCount","presignedUrl","start","end","Math","min","size","chunk","slice","Error","Promise","resolve","reject","xhr","XMLHttpRequest","timeout","upload","onprogress","event","lengthComputable","loaded","total","onload","status","etag","getResponseHeader","PartNumber","ETag","replace","onerror","ontimeout","open","setRequestHeader","send","catch","error","setTimeout","pow","i","race","chunkPromise","then","result","push","round","finally","delete","add","all","sortedParts","sort","a","b","success","parts","errorMessage","uploadVideo","options","toFixed","metadata","_progress","_status","thumbnail","uploadMetadata","presignedResponse","fetch","method","headers","Authorization","apiKey","body","JSON","stringify","fileName","fileSize","contentType","type","ok","presignedData","json","uploadResult","completeResponse","completeData","uploadThumbnail","data","videoId","video","id","thumbnailFile","formData","FormData","append","response","getVideoStatus","listVideos","style","primaryColor","secondaryColor","darkMode","width","height","showTitle","showDescription","embedUrl","params","join","React","createElement","src","frameBorder","allow","allowFullScreen","title","enable","window","localStorage","setItem","disable","removeItem"],"mappings":"yrBAIA,IAAIA,GAA0B,EAG9B,MAAMC,EAAgBC,EAAAA,QAAY,iBAuC3B,MAAMC,EAAM,SAASC,KAAoBC,GAC1CL,GACFC,EAAcG,KAAYC,EAE9B,WAMgBC,EAASF,KAAoBC,GACvCL,IACFO,QAAQJ,IAAI,mBAAmBC,OAAcC,GAC7CJ,EAAcG,KAAYC,GAE9B,CCzDc,MAAOG,EAGnB,WAAAC,CAAYC,GACVC,KAAKD,OAASA,EACdP,EAAI,8CAA+CO,EAAOE,UAC3D,CAKO,gBAAMC,CACZC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IACE,MAAMC,EAAaL,EAAcM,OAGjClB,EAAI,0BAA0BW,EAAKQ,SAASF,YAG5C,MAAMG,EAAgB,IAAIC,MAAMJ,GAAYK,KAAK,GAE3CC,EAAwB,KAC5B,MAAMC,EAAgBJ,EAAcK,QAAO,CAACC,EAAKC,IAAaD,EAAMC,GAAU,GAE9EX,EADwBQ,EAAgBP,EACb,EAIvBW,EAAoB,EACpBC,EAAc,EACdC,EAAe,IAAIC,IACnBC,EAAwB,GAExBC,EAAcC,MAAOC,EAAeC,EAAa,KACrD,MAAMC,EAAezB,EAAcuB,GAC7BG,EAAQH,EAAQpB,EAChBwB,EAAMC,KAAKC,IAAIH,EAAQvB,EAAWJ,EAAK+B,MACvCC,EAAQhC,EAAKiC,MAAMN,EAAOC,GAMhC,GAHAnB,EAAce,GAAS,EACvBZ,IAEmB,IAAfoB,EAAMD,KACR,MAAM,IAAIG,MAAM,iCAAiCV,EAAQ,KAG3D,OAAO,IAAIW,SAA8C,CAACC,EAASC,KACjE,MAAMC,EAAM,IAAIC,eAChBD,EAAIE,QAAU,IAEdF,EAAIG,OAAOC,WAAcC,IACnBA,EAAMC,mBACRnC,EAAce,GAAUmB,EAAME,OAASF,EAAMG,MAAS,IACtDlC,IACD,EAGH0B,EAAIS,OAAS,KACX,GAAIT,EAAIU,QAAU,KAAOV,EAAIU,OAAS,IAAK,CACzC,MAAMC,EAAOX,EAAIY,kBAAkB,QACnC,IAAKD,EAEH,YADAZ,EAAO,IAAIH,MAAM,6BAA6BV,EAAQ,MAIxDf,EAAce,GAAS,IACvBZ,IACAvB,EAAI,WAAWmC,EAAQ,KAAKlB,eAE5B8B,EAAQ,CACNe,WAAY3B,EAAQ,EACpB4B,KAAMH,EAAKI,QAAQ,KAAM,KAE5B,MACChB,EAAO,IAAIH,MAAM,QAAQI,EAAIU,iCAAiCxB,EAAQ,KACvE,EAGHc,EAAIgB,QAAU,IAAMjB,EAAO,IAAIH,MAAM,gCAAgCV,EAAQ,MAC7Ec,EAAIiB,UAAY,IAAMlB,EAAO,IAAIH,MAAM,0BAA0BV,EAAQ,MAEzEc,EAAIkB,KAAK,MAAO9B,GAChBY,EAAImB,iBAAiB,eAAgB,4BACrCnB,EAAIoB,KAAK1B,EAAM,IACd2B,OAAMpC,MAAOqC,IAEd,GAAInC,EAAaP,EAGf,OAFA7B,EAAI,YAAYmC,EAAQ,uBAAuBC,EAAa,KAAKP,OAAiB0C,EAAMtE,iBAClF,IAAI6C,SAAQC,GAAWyB,WAAWzB,EAAmC,IAA1BP,KAAKiC,IAAI,EAAGrC,MACtDH,EAAYE,EAAOC,EAAa,GAGvC,MADApC,EAAI,WAAWmC,EAAQ,kBAAkBN,cAAwB0C,EAAMtE,WACjEsE,CACP,GACD,EAIJ,IAAK,IAAIG,EAAI,EAAGA,EAAI9D,EAAcM,OAAQwD,IAAK,CAEzC5C,EAAaY,MAAQd,SACjBkB,QAAQ6B,KAAK7C,GAGrB,MAAM8C,EAAe3C,EAAYyC,GAC9BG,MAAKC,IACJ9C,EAAe+C,KAAKD,GACpB9E,EAAI,gBAAgBgC,EAAed,UAAUD,uBAAgCuB,KAAKwC,MAAOhD,EAAed,OAASD,EAAc,UACxH6D,KAERR,OAAMC,IAEL,MADAvE,EAAI,YAAY0E,EAAI,KAAKzD,yBAAkCsD,EAAMtE,WAC3DsE,CAAK,IAEZU,SAAQ,IAAMnD,EAAaoD,OAAON,KAErC9C,EAAaqD,IAAIP,EAClB,OAGK9B,QAAQsC,IAAItD,GAGlB,MAAMuD,EAAcrD,EAAesD,MAAK,CAACC,EAAGC,IAAMD,EAAEzB,WAAa0B,EAAE1B,aAInE,OAFA9D,EAAI,0BAA0BW,EAAKQ,SAASkE,EAAYnE,iBAEjD,CACLuE,SAAS,EACT5E,SAAUA,EACVC,MAAOA,EACP4E,MAAOL,EAGV,CAAC,MAAOd,GACP,MAAMoB,EAAepB,aAAiB1B,MAAQ0B,EAAMtE,QAAU,yBAE9D,OADAD,EAAI,uBAAuB2F,KACpB,CACLF,SAAS,EACT5E,SAAUA,EACVC,MAAOA,EACP4E,MAAO,GACPnB,MAAOoB,EAEV,CACF,CAKD,iBAAMC,CAAYjF,EAAYkF,GAC5B1F,EAAS,uBAAuBQ,EAAKQ,UAAUR,EAAK+B,KAAO,KAAO,MAAMoD,QAAQ,SAEhF,IACE,MAAMC,SACJA,EAAQ/E,WACRA,EAAa,CAACgF,EAAmBC,KAApB,EAAsFC,UACnGA,GACEL,EAGJ,IAAKK,EAEH,MADAlF,EAAW,EAAG,UACR,IAAI6B,MAAM,0CAIlB,MAAMsD,EAAiB,IAAKJ,EAAUtF,UAAWD,KAAKD,OAAOE,WAGvD2F,QAA0BC,MAAM,iCAAiC7F,KAAKD,OAAOE,mCAAoC,CACrH6F,OAAQ,OACRC,QAAS,CACP,eAAgB,mBAChBC,cAAiB,UAAUhG,KAAKD,OAAOkG,UAEzCC,KAAMC,KAAKC,UAAU,CACnBC,SAAUlG,EAAKQ,KACf2F,SAAUnG,EAAK+B,KACfqE,YAAapG,EAAKqG,KAClBjB,SAAUI,MAId,IAAKC,EAAkBa,GACrB,MAAM,IAAIpE,MAAM,sCAAsCuD,EAAkBzC,UAG1E,MAAMuD,QAAsBd,EAAkBe,OAE9C,IAAKD,EAAczB,QACjB,MAAM,IAAI5C,MAAMqE,EAAc3C,OAAS,qCAGzCvD,EAAW,EAAG,aAEd,MAAMoG,QAAqB5G,KAAKE,WAC9BC,EACAuG,EAActG,cACdsG,EAAcrG,SACdqG,EAAcpG,MACdoG,EAAcnG,WACbY,IACCX,EAAWW,EAAU,YAAY,IAIrC,IAAKyF,EAAa3B,QAChB,MAAM,IAAI5C,MAAMuE,EAAa7C,OAAS,oBAGxCvD,EAAW,IAAK,cAGhB,MAAMqG,QAAyBhB,MAAM,iCAAiC7F,KAAKD,OAAOE,4BAA6B,CAC7G6F,OAAQ,OACRC,QAAS,CACP,eAAgB,mBAChBC,cAAiB,UAAUhG,KAAKD,OAAOkG,UAEzCC,KAAMC,KAAKC,UAAU,CACnB/F,SAAUuG,EAAavG,SACvBC,MAAOsG,EAAatG,MACpB4E,MAAO0B,EAAa1B,UAIxB,IAAK2B,EAAiBJ,GACpB,MAAM,IAAIpE,MAAM,8BAA8BwE,EAAiB1D,UAGjE,MAAM2D,QAAqBD,EAAiBF,OAE5C,IAAKG,EAAa7B,QAChB,MAAM,IAAI5C,MAAMyE,EAAarH,SAAW,4BAO1C,aAHMO,KAAK+G,gBAAgBrB,EAAWoB,EAAaE,KAAKC,SACxDtH,EAAS,mCAAoCmH,EAAaE,KAAKC,SAExD,CACLhC,SAAS,EACTxF,QAAS,8BACTyH,MAAO,CACLC,GAAIL,EAAaE,KAAKC,SAI3B,CAAC,MAAOlD,GAGP,OAFApE,EAAS,oBAAoBoE,aAAiB1B,MAAQ0B,EAAMtE,QAAU,mBAE/D,CACLwF,SAAS,EACTxF,QAASsE,aAAiB1B,MAAQ0B,EAAMtE,QAAU,6CAErD,CACF,CAKO,qBAAMsH,CAAgBK,EAAqBH,GACjD,MAAMI,EAAW,IAAIC,SACrBD,EAASE,OAAO,YAAaH,GAE7B,IACE,MAAMI,QAAiB3B,MAAM,iCAAiC7F,KAAKD,OAAOE,oBAAoBgH,mBAA0B,CACtHnB,OAAQ,OACRI,KAAMmB,EACNtB,QAAS,CACPC,cAAiB,UAAUhG,KAAKD,OAAOkG,YAIrC3B,QAAekD,EAASb,OAC9B,IAAKrC,EAAOW,QACV,MAAM,IAAI5C,MAAMiC,EAAO7E,SAAW,2BAGpC,OAAO6E,CACR,CAAC,MAAOP,GACP,MAAM,IAAI1B,MAAM0B,aAAiB1B,MAAQ0B,EAAMtE,QAAU,6BAC1D,CACF,CAKD,oBAAMgI,CAAeR,GACnB,IACE,MAAMO,QAAiB3B,MAAM,iCAAiC7F,KAAKD,OAAOE,oBAAoBgH,WAAkB,CAC9GnB,OAAQ,MACRC,QAAS,CACPC,cAAiB,UAAUhG,KAAKD,OAAOkG,YAIrC3B,QAAekD,EAASb,OAC9B,IAAKrC,EAAOW,QACV,MAAM,IAAI5C,MAAMiC,EAAO7E,SAAW,8BAGpC,OAAO6E,CACR,CAAC,MAAOP,GACP,MAAM,IAAI1B,MAAM0B,aAAiB1B,MAAQ0B,EAAMtE,QAAU,6BAC1D,CACF,CAKD,gBAAMiI,GACJ,IACE,MAAMF,QAAiB3B,MAAM,iCAAiC7F,KAAKD,OAAOE,mBAAoB,CAC5F6F,OAAQ,MACRC,QAAS,CACPC,cAAiB,UAAUhG,KAAKD,OAAOkG,YAIrC3B,QAAekD,EAASb,OAE9B,OAAKrC,EAAOW,QAOLX,EANE,CACLW,SAAS,EACTxF,QAAS6E,EAAO7E,SAAW,4BAKhC,CAAC,MAAOsE,GACP,MAAO,CACLkB,SAAS,EACTxF,QAASsE,aAAiB1B,MAAQ0B,EAAMtE,QAAU,4BAErD,CACF,mBC3UmD,EAAGwH,UAASlH,SAAQ4H,QAAQ,CAAE,MAClF,MAAMC,aAAEA,EAAYC,eAAEA,EAAcC,SAAEA,EAAQC,MAAEA,EAAKC,OAAEA,EAAMC,UAAEA,EAASC,gBAAEA,GAAoBP,EAE9F,IAAIQ,EAAW,yCAAyClB,IACxD,MAAMmB,EAAmB,GAgBzB,OAdIR,GAAcQ,EAAO7D,KAAK,iBAAiBqD,EAAapE,QAAQ,IAAK,OACrEqE,GAAgBO,EAAO7D,KAAK,mBAAmBsD,EAAerE,QAAQ,IAAK,OAC3EsE,GAAUM,EAAO7D,KAAK,kBACtB0D,GAAWG,EAAO7D,KAAK,mBACvB2D,GAAiBE,EAAO7D,KAAK,yBAGjC6D,EAAO7D,KAAK,cAAcxE,EAAOE,aACjCmI,EAAO7D,KAAK,WAAWxE,EAAOkG,UAE1BmC,EAAO1H,OAAS,IAClByH,GAAY,IAAIC,EAAOC,KAAK,QAI5BC,EACIC,cAAA,SAAA,CAAAC,IAAKL,EACLR,MAAO,CAACI,MAAOA,GAAS,OAAQC,OAAQA,GAAU,QAClDS,YAAY,IACZC,MAAM,2FACNC,iBAAe,EACfC,MAAO,mBAAmB3B,KAE9B,qBC7BsD,EAAGA,UAASlH,SAAQ4H,QAAQ,CAAE,MACtF,MAAMC,aAAEA,EAAYC,eAAEA,EAAcC,SAAEA,EAAQC,MAAEA,EAAKC,OAAEA,EAAMC,UAAEA,EAASC,gBAAEA,GAAoBP,EAE9F,IAAIQ,EAAW,0CAA0ClB,IACzD,MAAMmB,EAAmB,GAiBzB,OAfIR,GAAcQ,EAAO7D,KAAK,iBAAiBqD,EAAapE,QAAQ,IAAK,OACrEqE,GAAgBO,EAAO7D,KAAK,mBAAmBsD,EAAerE,QAAQ,IAAK,OAC3EsE,GAAUM,EAAO7D,KAAK,kBACtB0D,GAAWG,EAAO7D,KAAK,mBACvB2D,GAAiBE,EAAO7D,KAAK,yBAIjC6D,EAAO7D,KAAK,cAAcxE,EAAOE,aACjCmI,EAAO7D,KAAK,WAAWxE,EAAOkG,UAE1BmC,EAAO1H,OAAS,IAClByH,GAAY,IAAIC,EAAOC,KAAK,QAI5BC,EACIC,cAAA,SAAA,CAAAC,IAAKL,EACLR,MAAO,CAACI,MAAOA,GAAS,OAAQC,OAAQA,GAAU,QAClDS,YAAY,IACZC,MAAM,2FACNC,iBAAe,EACfC,MAAO,mBAAmB3B,KAE9B,mBCpBGvF,eAA8BuF,EAAiBlH,GAEpD,OADe,IAAIF,EAAgBE,GACrB0H,eAAeR,EAC/B,kCJSE,OAAO5H,CACT,eIJOqC,eAA0B3B,GAE/B,OADe,IAAIF,EAAgBE,GACrB2H,YAChB,iBJ3BM,SAAuBmB,GAC3BxJ,EAAiBwJ,EAEbA,GAEFtJ,UAAYsJ,OAAO,iBAGG,oBAAXC,QACTA,OAAOC,aAAaC,QAAQ,QAAS,mBAIvCzJ,EAAW,QAAC0J,UAGU,oBAAXH,QACTA,OAAOC,aAAaG,WAAW,SAGrC,gBIfOxH,eAA2BvB,EAAYkF,EAActF,GAE1D,OADe,IAAIF,EAAgBE,GACrBqF,YAAYjF,EAAMkF,EAClC"}